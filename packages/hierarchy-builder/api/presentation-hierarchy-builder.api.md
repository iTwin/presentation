## API Report File for "@itwin/presentation-hierarchy-builder"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @beta
export interface ArrayPropertyAttributes {
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minOccurs: number;
}

// @beta
export interface BaseGroupingNodeKey {
    groupedInstanceKeys: InstanceKey[];
}

// @beta
export class BisInstanceLabelSelectClauseFactory implements IInstanceLabelSelectClauseFactory {
    constructor(props: BisInstanceLabelSelectClauseFactoryProps);
    // (undocumented)
    createSelectClause(props: CreateInstanceLabelSelectClauseProps): Promise<string>;
}

// @beta
export interface BisInstanceLabelSelectClauseFactoryProps {
    // (undocumented)
    metadataProvider: IMetadataProvider;
}

// @beta
export interface ClassBasedHierarchyDefinition {
    childNodes: Array<ClassBasedHierarchyLevelDefinition>;
    rootNodes: (props: DefineRootHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
}

// @beta
export interface ClassBasedHierarchyDefinitionsFactoryProps {
    hierarchy: ClassBasedHierarchyDefinition;
    metadataProvider: IMetadataProvider;
}

// @beta
export type ClassBasedHierarchyLevelDefinition = InstancesNodeChildHierarchyLevelDefinition | CustomNodeChildHierarchyLevelDefinition;

// @beta
export class ClassBasedHierarchyLevelDefinitionsFactory implements IHierarchyLevelDefinitionsFactory {
    constructor(props: ClassBasedHierarchyDefinitionsFactoryProps);
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
}

// @beta
export class ClassBasedInstanceLabelSelectClauseFactory implements IInstanceLabelSelectClauseFactory {
    constructor(props: ClassBasedInstanceLabelSelectClauseFactoryProps);
    // (undocumented)
    createSelectClause(props: CreateInstanceLabelSelectClauseProps): Promise<string>;
}

// @beta
export interface ClassBasedInstanceLabelSelectClauseFactoryProps {
    clauses: ClassBasedLabelSelectClause[];
    defaultClauseFactory?: IInstanceLabelSelectClauseFactory;
    metadataProvider: IMetadataProvider;
}

// @beta
export interface ClassBasedLabelSelectClause {
    className: string;
    clause: (props: CreateInstanceLabelSelectClauseProps) => Promise<string>;
}

// @beta
export interface ClassGroupingNodeKey extends BaseGroupingNodeKey {
    class: {
        name: string;
        label?: string;
    };
    type: "class-grouping";
}

// @beta
export type ConcatenatedValue = ConcatenatedValuePart | ConcatenatedValuePart[];

// @beta (undocumented)
export namespace ConcatenatedValue {
    export function serialize(parts: ConcatenatedValue, partFormatter: (part: ConcatenatedValuePart) => Promise<string>): Promise<string>;
}

// @beta
export type ConcatenatedValuePart = PropertyValue | TypedPrimitiveValue | string;

// @beta (undocumented)
export namespace ConcatenatedValuePart {
    // (undocumented)
    export function isPrimitive(part: ConcatenatedValuePart): part is TypedPrimitiveValue;
    // (undocumented)
    export function isProperty(part: ConcatenatedValuePart): part is PropertyValue;
    // (undocumented)
    export function isString(part: ConcatenatedValuePart): part is string;
}

// @beta
export function createDefaultValueFormatter(): IPrimitiveValueFormatter;

// @beta
export interface CreateInstanceLabelSelectClauseProps {
    classAlias: string;
    className?: string;
    selectorsConcatenator?: (selectors: TypedValueSelectClauseProps[], checkSelector?: string) => string;
}

// @beta
export interface CustomHierarchyNodeDefinition {
    node: ParsedCustomHierarchyNode;
}

// @beta
export interface CustomNodeChildHierarchyLevelDefinition {
    customParentNodeKey: string;
    definitions: (requestProps: DefineHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
}

// @beta
export class DefaultInstanceLabelSelectClauseFactory implements IInstanceLabelSelectClauseFactory {
    // (undocumented)
    createSelectClause(props: CreateInstanceLabelSelectClauseProps): Promise<string>;
}

// @beta
export interface DefineHierarchyLevelProps {
    instanceFilter?: GenericInstanceFilter;
    parentNode: HierarchyDefinitionParentNode | undefined;
}

// @beta
export type DefineInstanceNodeChildHierarchyLevelProps = DefineHierarchyLevelProps & {
    parentNodeInstanceIds: Id64String[];
    parentNode: HierarchyDefinitionParentNode;
};

// @beta
export type DefineRootHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode">;

// @beta
export type ECArrayProperty = ECStructArrayProperty | ECEnumerationArrayProperty | ECPrimitiveArrayProperty;

// @beta
export interface ECClass extends ECSchemaItem {
    // (undocumented)
    getProperties(): Promise<Array<ECProperty>>;
    // (undocumented)
    getProperty(name: string): Promise<ECProperty | undefined>;
    // (undocumented)
    is(className: string, schemaName: string): Promise<boolean>;
    // (undocumented)
    is(other: ECClass): Promise<boolean>;
    // (undocumented)
    isEntityClass(): this is ECEntityClass;
    // (undocumented)
    isMixin(): this is ECMixin;
    // (undocumented)
    isRelationshipClass(): this is ECRelationshipClass;
    // (undocumented)
    isStructClass(): this is ECStructClass;
}

// @beta
export type ECEntityClass = ECClass;

// @beta
export interface ECEnumeration extends ECSchemaItem {
    // (undocumented)
    enumerators: Array<ECEnumerator<string | number>>;
    // (undocumented)
    isStrict: boolean;
    // (undocumented)
    type: "String" | "Number";
}

// @beta
export type ECEnumerationArrayProperty = ECEnumerationProperty & ArrayPropertyAttributes;

// @beta
export interface ECEnumerationProperty extends ECProperty {
    // (undocumented)
    enumeration: Promise<ECEnumeration | undefined>;
    // (undocumented)
    extendedTypeName?: string;
}

// @beta
export interface ECEnumerator<T> {
    // (undocumented)
    description?: string;
    // (undocumented)
    label?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    value: T;
}

// @beta
export type ECKindOfQuantity = ECSchemaItem;

// @beta
export type ECMixin = ECClass;

// @beta
export interface ECNavigationProperty extends ECProperty {
    // (undocumented)
    direction: "Forward" | "Backward";
    // (undocumented)
    relationshipClass: Promise<ECRelationshipClass>;
}

// @beta
export type ECPrimitiveArrayProperty = ECPrimitiveProperty & ArrayPropertyAttributes;

// @beta
export interface ECPrimitiveProperty extends ECProperty {
    // (undocumented)
    extendedTypeName?: string;
    // (undocumented)
    primitiveType: ECPrimitiveType;
}

// @beta
export type ECPrimitiveType = "Binary" | "Boolean" | "DateTime" | "Double" | "Integer" | "Long" | "Point2d" | "Point3d" | "String" | "IGeometry";

// @beta
export interface ECProperty {
    // (undocumented)
    class: ECClass;
    // (undocumented)
    isArray(): this is ECArrayProperty;
    // (undocumented)
    isEnumeration(): this is ECEnumerationProperty;
    // (undocumented)
    isNavigation(): this is ECNavigationProperty;
    // (undocumented)
    isPrimitive(): this is ECPrimitiveProperty;
    // (undocumented)
    isStruct(): this is ECStructProperty;
    // (undocumented)
    kindOfQuantity: Promise<ECKindOfQuantity | undefined>;
    // (undocumented)
    label?: string;
    // (undocumented)
    name: string;
}

// @beta
export interface ECRelationshipClass extends ECClass {
    // (undocumented)
    direction: "Forward" | "Backward";
    // (undocumented)
    source: ECRelationshipConstraint;
    // (undocumented)
    target: ECRelationshipConstraint;
}

// @beta
export interface ECRelationshipConstraint {
    // (undocumented)
    abstractConstraint: Promise<ECEntityClass | ECMixin | ECRelationshipClass | undefined>;
    // (undocumented)
    multiplicity?: ECRelationshipConstraintMultiplicity;
    // (undocumented)
    polymorphic: boolean;
}

// @beta
export interface ECRelationshipConstraintMultiplicity {
    // (undocumented)
    lowerLimit: number;
    // (undocumented)
    upperLimit: number;
}

// @beta
export interface ECSchema {
    // (undocumented)
    getClass(name: string): Promise<ECClass | undefined>;
    // (undocumented)
    name: string;
}

// @beta
export interface ECSchemaItem {
    // (undocumented)
    fullName: string;
    // (undocumented)
    label?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    schema: ECSchema;
}

// @beta
export type ECSqlBinding = {
    type: "boolean";
    value?: boolean;
} | {
    type: "double" | "int" | "long";
    value?: number;
} | {
    type: "id";
    value?: Id64String;
} | {
    type: "idset";
    value?: Id64String[];
} | {
    type: "string";
    value?: string;
} | {
    type: "point2d";
    value?: {
        x: number;
        y: number;
    };
} | {
    type: "point3d";
    value?: {
        x: number;
        y: number;
        z: number;
    };
};

// @beta
export type ECSqlBindingType = "boolean" | "double" | "id" | "idset" | "int" | "long" | "string" | "point2d" | "point3d";

// @beta
export interface ECSqlQueryDef {
    bindings?: ECSqlBinding[];
    ctes?: string[];
    ecsql: string;
}

// @beta
export type ECSqlQueryReader = AsyncIterableIterator<ECSqlQueryRow>;

// @beta
export interface ECSqlQueryReaderOptions {
    // (undocumented)
    rowFormat?: ECSqlQueryRowFormat;
}

// @beta
export interface ECSqlQueryRow {
    // (undocumented)
    [propertyName: string]: any;
    // (undocumented)
    [propertyIndex: number]: any;
}

// @beta
export type ECSqlQueryRowFormat = "ECSqlPropertyNames" | "Indexes";

// @beta
export interface ECSqlSelectClauseBaseClassGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    fullClassNames: string[] | ECSqlValueSelector[];
}

// @beta
export interface ECSqlSelectClauseGroupingParams {
    // (undocumented)
    byBaseClasses?: ECSqlSelectClauseBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | ECSqlSelectClauseGroupingParamsBase | ECSqlValueSelector;
    // (undocumented)
    byLabel?: ECSqlSelectClauseLabelGroupingParams;
    // (undocumented)
    byProperties?: ECSqlSelectClausePropertiesGroupingParams;
}

// @beta
export interface ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    autoExpand?: string | ECSqlValueSelector;
    // (undocumented)
    hideIfNoSiblings?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfOneGroupedNode?: boolean | ECSqlValueSelector;
}

// @beta
export interface ECSqlSelectClauseLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string | ECSqlValueSelector;
}

// @beta
export interface ECSqlSelectClauseLabelGroupingGroupParams extends ECSqlSelectClauseLabelGroupingBaseParams, ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @beta
export interface ECSqlSelectClauseLabelGroupingMergeParams extends ECSqlSelectClauseLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @beta
export type ECSqlSelectClauseLabelGroupingParams = boolean | ECSqlValueSelector | ECSqlSelectClauseLabelGroupingMergeParams | ECSqlSelectClauseLabelGroupingGroupParams;

// @beta
export interface ECSqlSelectClausePropertiesGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean | ECSqlValueSelector;
    createGroupForUnspecifiedValues?: boolean | ECSqlValueSelector;
    propertiesClassName: string;
    propertyGroups: Array<ECSqlSelectClausePropertyGroup>;
}

// @beta
export interface ECSqlSelectClausePropertyGroup {
    propertyClassAlias: string;
    propertyName: string;
    ranges?: Array<ECSqlSelectClausePropertyValueRange>;
}

// @beta
export interface ECSqlSelectClausePropertyValueRange {
    fromValue: number | ECSqlValueSelector;
    rangeLabel?: string | ECSqlValueSelector;
    toValue: number | ECSqlValueSelector;
}

// @beta
export const ECSqlSnippets: {
    createRawPropertyValueSelector(classAlias: string, propertyName: string, componentName?: string | undefined): string;
    createRawPrimitiveValueSelector(value: PrimitiveValue | undefined): string;
    createNullableSelector(props: {
        checkSelector: string;
        valueSelector: string;
    }): string;
    createConcatenatedValueJsonSelector(selectors: ECSqlValueSnippets.TypedValueSelectClauseProps[], checkSelector?: string | undefined): string;
    createConcatenatedValueStringSelector(selectors: ECSqlValueSnippets.TypedValueSelectClauseProps[], checkSelector?: string | undefined): string;
    TypedValueSelectClauseProps: typeof ECSqlValueSnippets.TypedValueSelectClauseProps;
    createRelationshipPathJoinClause(props: ECSqlJoinSnippets.CreateRelationshipPathJoinClauseProps): Promise<string>;
};

// @beta
export interface ECSqlValueSelector {
    // (undocumented)
    selector: string;
}

// @beta
export type ECStructArrayProperty = ECStructProperty & ArrayPropertyAttributes;

// @beta
export type ECStructClass = ECClass;

// @beta
export interface ECStructProperty extends ECProperty {
    // (undocumented)
    structClass: ECStructClass;
}

// @beta
export interface GenericInstanceFilter {
    filterClassNames?: string[];
    propertyClassName: string;
    relatedInstances: RelatedInstanceDescription[];
    rules: GenericInstanceFilterRule | GenericInstanceFilterRuleGroup;
}

// @beta (undocumented)
export namespace GenericInstanceFilter {
    export function isFilterRuleGroup(obj: GenericInstanceFilterRule | GenericInstanceFilterRuleGroup): obj is GenericInstanceFilterRuleGroup;
}

// @beta
export interface GenericInstanceFilterRule {
    operator: PropertyFilterRuleOperator;
    propertyName: string;
    sourceAlias?: string;
    value?: PropertyFilterValue;
}

// @beta
export interface GenericInstanceFilterRuleGroup {
    operator: PropertyFilterRuleGroupOperator;
    rules: Array<GenericInstanceFilterRule | GenericInstanceFilterRuleGroup>;
}

// @beta
export interface GetHierarchyNodesProps {
    hierarchyLevelSizeLimit?: number | "unbounded";
    instanceFilter?: GenericInstanceFilter;
    parentNode: ParentHierarchyNode | undefined;
}

// @beta
export function getLogger(): ILogger;

// @beta
export type GroupingNodeKey = ClassGroupingNodeKey | LabelGroupingNodeKey | PropertyGroupingNodeKey;

// @beta
export type HierarchyDefinitionParentNode = Omit<HierarchyNode, "children" | "key"> & {
    key: InstancesNodeKey | string;
};

// @beta
export type HierarchyLevelDefinition = HierarchyNodesDefinition[];

// @beta
export interface HierarchyNode {
    autoExpand?: boolean;
    children: boolean;
    extendedData?: {
        [key: string]: any;
    };
    key: HierarchyNodeKey;
    label: string;
    parentKeys: HierarchyNodeKey[];
    supportsFiltering?: boolean;
}

// @beta (undocumented)
export namespace HierarchyNode {
    export function isClassGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: ClassGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? {
        children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    } : {});
    export function isCustom<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: string;
    } & (TNode extends ProcessedHierarchyNode ? {
        processingParams?: HierarchyNodeProcessingParamsBase;
    } : {});
    export function isGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: GroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? {
        children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    } : {});
    export function isInstancesNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: InstancesNodeKey;
    } & (TNode extends ProcessedHierarchyNode ? {
        processingParams?: InstanceHierarchyNodeProcessingParams;
    } : {});
    export function isLabelGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: LabelGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? {
        children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    } : {});
    export function isPropertyOtherValuesGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyOtherValuesGroupingNodeKey;
    } & (TNode extends ProcessedHierarchyNode ? {
        children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    } : {});
    export function isPropertyValueGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueGroupingNodeKey;
    } & (TNode extends ProcessedHierarchyNode ? {
        children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    } : {});
    export function isPropertyValueRangeGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueRangeGroupingNodeKey;
    } & (TNode extends ProcessedHierarchyNode ? {
        children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    } : {});
    export function isStandard<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: StandardHierarchyNodeKey;
    };
}

// @beta
export type HierarchyNodeAutoExpandProp = "single-child" | "always";

// @beta
export interface HierarchyNodeBaseClassGroupingParams extends HierarchyNodeGroupingParamsBase {
    fullClassNames: string[];
}

// @beta
export interface HierarchyNodeGroupingParams {
    // (undocumented)
    byBaseClasses?: HierarchyNodeBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | HierarchyNodeGroupingParamsBase;
    // (undocumented)
    byLabel?: HierarchyNodeLabelGroupingParams;
    // (undocumented)
    byProperties?: HierarchyNodePropertiesGroupingParams;
}

// @beta
export interface HierarchyNodeGroupingParamsBase {
    autoExpand?: HierarchyNodeAutoExpandProp;
    hideIfNoSiblings?: boolean;
    hideIfOneGroupedNode?: boolean;
}

// @beta
export type HierarchyNodeIdentifier = InstanceKey | {
    key: string;
};

// @beta (undocumented)
export namespace HierarchyNodeIdentifier {
    export function equal(lhs: HierarchyNodeIdentifier, rhs: HierarchyNodeIdentifier): boolean;
    export function isCustomNodeIdentifier(id: HierarchyNodeIdentifier): id is {
        key: string;
    };
    export function isInstanceNodeIdentifier(id: HierarchyNodeIdentifier): id is InstanceKey;
}

// @beta
export type HierarchyNodeIdentifiersPath = HierarchyNodeIdentifier[];

// @beta
export type HierarchyNodeKey = StandardHierarchyNodeKey | string;

// @beta (undocumented)
export namespace HierarchyNodeKey {
    export function equals(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): boolean;
    export function isClassGrouping(key: HierarchyNodeKey): key is ClassGroupingNodeKey;
    export function isCustom(key: HierarchyNodeKey): key is string;
    export function isGrouping(key: HierarchyNodeKey): key is GroupingNodeKey;
    export function isInstances(key: HierarchyNodeKey): key is InstancesNodeKey;
    export function isLabelGrouping(key: HierarchyNodeKey): key is LabelGroupingNodeKey;
    export function isPropertyOtherValuesGrouping(key: HierarchyNodeKey): key is PropertyOtherValuesGroupingNodeKey;
    export function isPropertyValueGrouping(key: HierarchyNodeKey): key is PropertyValueGroupingNodeKey;
    export function isPropertyValueRangeGrouping(key: HierarchyNodeKey): key is PropertyValueRangeGroupingNodeKey;
    export function isStandard(key: HierarchyNodeKey): key is StandardHierarchyNodeKey;
}

// @beta
export interface HierarchyNodeLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string;
}

// @beta
export interface HierarchyNodeLabelGroupingGroupParams extends HierarchyNodeLabelGroupingBaseParams, HierarchyNodeGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @beta
export interface HierarchyNodeLabelGroupingMergeParams extends HierarchyNodeLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @beta
export type HierarchyNodeLabelGroupingParams = boolean | HierarchyNodeLabelGroupingMergeParams | HierarchyNodeLabelGroupingGroupParams;

// @beta
export interface HierarchyNodeProcessingParamsBase {
    hideIfNoChildren?: boolean;
    hideInHierarchy?: boolean;
}

// @beta
export interface HierarchyNodePropertiesGroupingParams extends HierarchyNodeGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    propertiesClassName: string;
    propertyGroups: Array<HierarchyNodePropertyGroup>;
}

// @beta
export interface HierarchyNodePropertyGroup {
    propertyName: string;
    propertyValue?: PrimitiveValue;
    ranges?: Array<HierarchyNodePropertyValueRange>;
}

// @beta
export interface HierarchyNodePropertyValueRange {
    fromValue: number;
    rangeLabel?: string;
    toValue: number;
}

// @beta
export type HierarchyNodesDefinition = CustomHierarchyNodeDefinition | InstanceNodesQueryDefinition;

// @beta (undocumented)
export namespace HierarchyNodesDefinition {
    // (undocumented)
    export function isCustomNode(def: HierarchyNodesDefinition): def is CustomHierarchyNodeDefinition;
    // (undocumented)
    export function isInstanceNodesQuery(def: HierarchyNodesDefinition): def is InstanceNodesQueryDefinition;
}

// @beta
export class HierarchyProvider {
    constructor(props: HierarchyProviderProps);
    // (undocumented)
    getNodes(props: GetHierarchyNodesProps): Promise<HierarchyNode[]>;
    readonly hierarchyDefinition: IHierarchyLevelDefinitionsFactory;
    readonly limitingQueryExecutor: ILimitingECSqlQueryExecutor;
    // @internal (undocumented)
    get queryScheduler(): {
        schedule: ILimitingECSqlQueryExecutor["createQueryReader"];
    };
}

// @beta
export interface HierarchyProviderProps {
    filtering?: {
        paths: HierarchyNodeIdentifiersPath[];
    };
    formatter?: IPrimitiveValueFormatter;
    hierarchyDefinition: IHierarchyLevelDefinitionsFactory;
    metadataProvider: IMetadataProvider;
    queryConcurrency?: number;
    queryExecutor: IECSqlQueryExecutor;
}

// @beta
export type Id64String = string;

// @beta
export interface IECSqlQueryExecutor {
    // (undocumented)
    createQueryReader(ecsql: string, bindings?: ECSqlBinding[], config?: ECSqlQueryReaderOptions): ECSqlQueryReader;
}

// @beta
export interface IHierarchyLevelDefinitionsFactory {
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
    parseNode?: INodeParser;
    postProcessNode?: INodePostProcessor;
    preProcessNode?: INodePreProcessor;
}

// @beta
export interface IInstanceLabelSelectClauseFactory {
    createSelectClause(props: CreateInstanceLabelSelectClauseProps): Promise<string>;
}

// @beta
export interface ILimitingECSqlQueryExecutor {
    createQueryReader(query: ECSqlQueryDef, config?: ECSqlQueryReaderOptions & {
        limit?: number | "unbounded";
    }): ECSqlQueryReader;
}

// @beta
export interface ILogger {
    // (undocumented)
    logError: LogFunction;
    // (undocumented)
    logInfo: LogFunction;
    // (undocumented)
    logTrace: LogFunction;
    // (undocumented)
    logWarning: LogFunction;
}

// @beta
export interface IMetadataProvider {
    // (undocumented)
    getSchema(schemaName: string): Promise<ECSchema | undefined>;
}

// @beta
export type INodeParser = (row: {
    [columnName: string]: any;
}) => ParsedInstanceHierarchyNode;

// @beta
export type INodePostProcessor = (node: ProcessedHierarchyNode) => Promise<ProcessedHierarchyNode>;

// @beta
export type INodePreProcessor = <TNode extends ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode>(node: TNode) => Promise<TNode | undefined>;

// @beta
export interface InstanceHierarchyNodeProcessingParams extends HierarchyNodeProcessingParamsBase {
    // (undocumented)
    grouping?: HierarchyNodeGroupingParams;
}

// @beta
export interface InstanceKey {
    className: string;
    id: Id64String;
}

// @beta (undocumented)
export namespace InstanceKey {
    export function equals(lhs: InstanceKey, rhs: InstanceKey): boolean;
}

// @beta
export interface InstanceNodesQueryDefinition {
    fullClassName: string;
    query: ECSqlQueryDef;
}

// @beta
export interface InstancesNodeChildHierarchyLevelDefinition {
    definitions: (requestProps: DefineInstanceNodeChildHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
    parentNodeClassName: string;
}

// @beta
export interface InstancesNodeKey {
    instanceKeys: InstanceKey[];
    type: "instances";
}

// @beta
export type IPrimitiveValueFormatter = (value: TypedPrimitiveValue) => Promise<string>;

// @beta
export interface LabelGroupingNodeKey extends BaseGroupingNodeKey {
    groupId?: string;
    label: string;
    type: "label-grouping";
}

// @beta
export const LOCALIZATION_NAMESPACE = "PresentationHierarchyBuilder";

// @beta
export type LocalizationFunction = (input: string) => string;

// @beta (undocumented)
export type LogFunction = (category: string, message: string) => void;

// @beta
export enum NodeSelectClauseColumnNames {
    AutoExpand = "AutoExpand",
    DisplayLabel = "DisplayLabel",
    ECInstanceId = "ECInstanceId",
    ExtendedData = "ExtendedData",
    FullClassName = "FullClassName",
    Grouping = "Grouping",
    HasChildren = "HasChildren",
    HideIfNoChildren = "HideIfNoChildren",
    HideNodeInHierarchy = "HideNodeInHierarchy",
    SupportsFiltering = "SupportsFiltering"
}

// @beta
export interface NodeSelectClauseProps {
    // (undocumented)
    autoExpand?: boolean | ECSqlValueSelector;
    // (undocumented)
    ecClassId: Id64String | ECSqlValueSelector;
    // (undocumented)
    ecInstanceId: Id64String | ECSqlValueSelector;
    // (undocumented)
    extendedData?: {
        [key: string]: Id64String | string | number | boolean | ECSqlValueSelector;
    };
    // (undocumented)
    grouping?: ECSqlSelectClauseGroupingParams;
    // (undocumented)
    hasChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfNoChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideNodeInHierarchy?: boolean | ECSqlValueSelector;
    // (undocumented)
    nodeLabel: string | ECSqlValueSelector;
    // (undocumented)
    supportsFiltering?: boolean | ECSqlValueSelector;
}

// @beta
export class NodeSelectQueryFactory {
    constructor(_metadataProvider: IMetadataProvider);
    createFilterClauses(def: GenericInstanceFilter | undefined, contentClass: {
        fullName: string;
        alias: string;
    }): Promise<{
        from: string;
        where: string;
        joins: string;
    }>;
    createSelectClause(props: NodeSelectClauseProps): Promise<string>;
}

// @beta
export type ParentHierarchyNode = Omit<HierarchyNode, "children">;

// @beta
export type ParsedCustomHierarchyNode = Omit<ProcessedCustomHierarchyNode, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @beta
export type ParsedHierarchyNode = ParsedCustomHierarchyNode | ParsedInstanceHierarchyNode;

// @beta
export type ParsedInstanceHierarchyNode = Omit<ProcessedInstanceHierarchyNode, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @beta
export function parseFullClassName(fullClassName: string): {
    schemaName: string;
    className: string;
};

// @beta
export interface Point2d {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @beta
export interface Point3d {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @beta
export type PrimitiveValue = Id64String | string | number | boolean | Date | Point2d | Point3d;

// @beta (undocumented)
export namespace PrimitiveValue {
    // (undocumented)
    export function isPoint2d(value: PrimitiveValue): value is Point2d;
    // (undocumented)
    export function isPoint3d(value: PrimitiveValue): value is Point3d;
}

// @beta
export type PrimitiveValueType = "Id" | Exclude<ECPrimitiveType, "Binary" | "IGeometry">;

// @beta
export type ProcessedCustomHierarchyNode = Omit<HierarchyNode, "key" | "children"> & {
    key: string;
    children?: boolean;
    processingParams?: HierarchyNodeProcessingParamsBase;
};

// @beta
export type ProcessedGroupingHierarchyNode = Omit<HierarchyNode, "key" | "children"> & {
    key: GroupingNodeKey;
    children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
    supportsFiltering?: undefined;
};

// @beta
export type ProcessedHierarchyNode = ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode | ProcessedGroupingHierarchyNode;

// @beta
export type ProcessedInstanceHierarchyNode = Omit<HierarchyNode, "key" | "children"> & {
    key: InstancesNodeKey;
    children?: boolean;
    processingParams?: InstanceHierarchyNodeProcessingParams;
};

// @beta
export type PropertyFilterRuleBinaryOperator = "Equal" | "NotEqual" | "Greater" | "GreaterOrEqual" | "Less" | "LessOrEqual" | "Like";

// @beta
export type PropertyFilterRuleGroupOperator = "And" | "Or";

// @beta
export type PropertyFilterRuleOperator = PropertyFilterRuleUnaryOperator | PropertyFilterRuleBinaryOperator;

// @beta (undocumented)
export namespace PropertyFilterRuleOperator {
    // (undocumented)
    export function isBinary(op: PropertyFilterRuleOperator): op is PropertyFilterRuleBinaryOperator;
    // (undocumented)
    export function isUnary(op: PropertyFilterRuleOperator): op is PropertyFilterRuleUnaryOperator;
}

// @beta
export type PropertyFilterRuleUnaryOperator = "True" | "False" | "Null" | "NotNull";

// @beta
export type PropertyFilterValue = PrimitiveValue | InstanceKey;

// @beta (undocumented)
export namespace PropertyFilterValue {
    export function isInstanceKey(value: PropertyFilterValue): value is InstanceKey;
    export function isPrimitive(value: PropertyFilterValue): value is PrimitiveValue;
}

// @beta
export type PropertyGroupingNodeKey = PropertyValueRangeGroupingNodeKey | PropertyValueGroupingNodeKey | PropertyOtherValuesGroupingNodeKey;

// @beta
export interface PropertyOtherValuesGroupingNodeKey extends BaseGroupingNodeKey {
    type: "property-grouping:other";
}

// @beta
export interface PropertyValue {
    // (undocumented)
    className: string;
    // (undocumented)
    propertyName: string;
    // (undocumented)
    value: PrimitiveValue;
}

// @beta
export interface PropertyValueGroupingNodeKey extends BaseGroupingNodeKey {
    formattedPropertyValue: string;
    propertyClassName: string;
    propertyName: string;
    type: "property-grouping:value";
}

// @beta
export interface PropertyValueRangeGroupingNodeKey extends BaseGroupingNodeKey {
    fromValue: number;
    propertyClassName: string;
    propertyName: string;
    toValue: number;
    type: "property-grouping:range";
}

// @beta
export interface RelatedInstanceDescription {
    alias: string;
    path: RelationshipPath;
}

// @beta
export type RelationshipPath<TStep extends RelationshipPathStep = RelationshipPathStep> = TStep[];

// @beta
export interface RelationshipPathStep {
    relationshipName: string;
    relationshipReverse?: boolean;
    sourceClassName: string;
    targetClassName: string;
}

// @beta
export class RowsLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @beta
export function setLocalizationFunction(localizationFunction?: LocalizationFunction): void;

// @beta
export function setLogger(logger: ILogger | undefined): void;

// @beta
export type StandardHierarchyNodeKey = InstancesNodeKey | GroupingNodeKey;

// @beta
export type TypedPrimitiveValue = ({
    value: number;
    type: "Integer" | "Long";
} | {
    value: number;
    type: "Double";
    koqName?: string;
} | {
    value: boolean;
    type: "Boolean";
} | {
    value: Id64String;
    type: "Id";
} | {
    value: string;
    type: "String";
} | {
    value: number | string | Date;
    type: "DateTime";
} | {
    value: Point2d;
    type: "Point2d";
} | {
    value: Point3d;
    type: "Point3d";
}) & {
    extendedType?: string;
};

// @beta
export namespace TypedPrimitiveValue {
    export function create(value: PrimitiveValue, type: PrimitiveValueType, koqName?: string, extendedType?: string): TypedPrimitiveValue;
}

// (No @packageDocumentation comment for this package)

```
