## API Report File for "@itwin/presentation-hierarchies"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConcatenatedValue } from '@itwin/presentation-shared';
import { ECClassHierarchyInspector } from '@itwin/presentation-shared';
import { ECSchemaProvider } from '@itwin/presentation-shared';
import { ECSqlQueryDef } from '@itwin/presentation-shared';
import { ECSqlQueryExecutor } from '@itwin/presentation-shared';
import { ECSqlQueryReaderOptions } from '@itwin/presentation-shared';
import { GenericInstanceFilter } from '@itwin/core-common';
import { Id64String } from '@itwin/core-bentley';
import { ILogger } from '@itwin/presentation-shared';
import { InstanceKey } from '@itwin/presentation-shared';
import { IPrimitiveValueFormatter } from '@itwin/presentation-shared';
import { OmitOverUnion } from '@itwin/presentation-shared';
import { PrimitiveValue } from '@itwin/presentation-shared';

// @beta
export function createClassBasedHierarchyLevelDefinitionsFactory(props: ClassBasedHierarchyDefinitionsFactoryProps): HierarchyLevelDefinitionsFactory;

// @beta
export function createHierarchyProvider(props: HierarchyProviderProps): HierarchyProvider;

// @beta
export function createLimitingECSqlQueryExecutor(baseExecutor: ECSqlQueryExecutor, defaultLimit: number | "unbounded"): LimitingECSqlQueryExecutor;

// @beta
export function createNodesQueryClauseFactory(props: {
    imodelAccess: ECSchemaProvider & ECClassHierarchyInspector;
}): NodesQueryClauseFactory;

// @beta
export type DefineCustomNodeChildHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode"> & {
    parentNode: Omit<HierarchyDefinitionParentNode, "key"> & {
        key: string;
    };
};

// @beta
export interface DefineHierarchyLevelProps {
    instanceFilter?: GenericInstanceFilter;
    parentNode: HierarchyDefinitionParentNode | undefined;
}

// @beta
export type DefineInstanceNodeChildHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode"> & {
    parentNode: Omit<HierarchyDefinitionParentNode, "key"> & {
        key: InstancesNodeKey;
    };
    parentNodeClassName: string;
    parentNodeInstanceIds: Id64String[];
};

// @beta
export type DefineRootHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode">;

export { GenericInstanceFilter }

// @beta
export interface GetHierarchyNodesProps {
    hierarchyLevelSizeLimit?: number | "unbounded";
    ignoreCache?: boolean;
    instanceFilter?: GenericInstanceFilter;
    parentNode: ParentHierarchyNode | undefined;
}

// @beta
export function getLogger(): ILogger;

// @beta
export interface GroupingHierarchyNode extends BaseHierarchyNode {
    groupedInstanceKeys: InstanceKey[];
    key: GroupingNodeKey;
    nonGroupingAncestor?: ParentHierarchyNode<NonGroupingHierarchyNode>;
}

// @beta
export type GroupingNodeKey = ClassGroupingNodeKey | LabelGroupingNodeKey | PropertyGroupingNodeKey;

// @beta
export type HierarchyLevelDefinition = HierarchyNodesDefinition[];

// @beta
export interface HierarchyLevelDefinitionsFactory {
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
    parseNode?: NodeParser;
    postProcessNode?: NodePostProcessor;
    preProcessNode?: NodePreProcessor;
}

// @beta
export type HierarchyNode = NonGroupingHierarchyNode | GroupingHierarchyNode;

// @beta (undocumented)
export namespace HierarchyNode {
    export function isClassGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: ClassGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isCustom<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & (TNode extends ProcessedHierarchyNode ? ProcessedCustomHierarchyNode : NonGroupingHierarchyNode) & {
        key: string;
    };
    export function isGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isInstancesNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & (TNode extends ProcessedHierarchyNode ? ProcessedInstanceHierarchyNode : NonGroupingHierarchyNode) & {
        key: InstancesNodeKey;
    };
    export function isLabelGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: LabelGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyOtherValuesGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyOtherValuesGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyValueGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyValueRangeGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueRangeGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isStandard<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: StandardHierarchyNodeKey;
    };
}

// @beta
export type HierarchyNodeIdentifier = InstanceKey | {
    key: string;
};

// @beta (undocumented)
export namespace HierarchyNodeIdentifier {
    export function equal(lhs: HierarchyNodeIdentifier, rhs: HierarchyNodeIdentifier): boolean;
    export function isCustomNodeIdentifier(id: HierarchyNodeIdentifier): id is {
        key: string;
    };
    export function isInstanceNodeIdentifier(id: HierarchyNodeIdentifier): id is InstanceKey;
}

// @beta
export type HierarchyNodeIdentifiersPath = HierarchyNodeIdentifier[];

// @beta
export type HierarchyNodeKey = StandardHierarchyNodeKey | string;

// @beta (undocumented)
export namespace HierarchyNodeKey {
    export function compare(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): number;
    export function equals(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): boolean;
    export function isClassGrouping(key: HierarchyNodeKey): key is ClassGroupingNodeKey;
    export function isCustom(key: HierarchyNodeKey): key is string;
    export function isGrouping(key: HierarchyNodeKey): key is GroupingNodeKey;
    export function isInstances(key: HierarchyNodeKey): key is InstancesNodeKey;
    export function isLabelGrouping(key: HierarchyNodeKey): key is LabelGroupingNodeKey;
    export function isPropertyGrouping(key: HierarchyNodeKey): key is PropertyGroupingNodeKey;
    export function isPropertyOtherValuesGrouping(key: HierarchyNodeKey): key is PropertyOtherValuesGroupingNodeKey;
    export function isPropertyValueGrouping(key: HierarchyNodeKey): key is PropertyValueGroupingNodeKey;
    export function isPropertyValueRangeGrouping(key: HierarchyNodeKey): key is PropertyValueRangeGroupingNodeKey;
    export function isStandard(key: HierarchyNodeKey): key is StandardHierarchyNodeKey;
}

// @beta
export type HierarchyNodesDefinition = CustomHierarchyNodeDefinition | InstanceNodesQueryDefinition;

// @beta (undocumented)
export namespace HierarchyNodesDefinition {
    // (undocumented)
    export function isCustomNode(def: HierarchyNodesDefinition): def is CustomHierarchyNodeDefinition;
    // (undocumented)
    export function isInstanceNodesQuery(def: HierarchyNodesDefinition): def is InstanceNodesQueryDefinition;
}

// @beta
export interface HierarchyProvider {
    getNodeInstanceKeys(props: Omit<GetHierarchyNodesProps, "ignoreCache">): AsyncIterableIterator<InstanceKey>;
    getNodes(props: GetHierarchyNodesProps): AsyncIterableIterator<HierarchyNode>;
    notifyDataSourceChanged(): void;
    setFormatter(formatter: IPrimitiveValueFormatter | undefined): void;
}

// @beta
export interface InstancesNodeKey {
    instanceKeys: InstanceKey[];
    type: "instances";
}

// @beta
export interface LimitingECSqlQueryExecutor {
    createQueryReader(query: ECSqlQueryDef, config?: ECSqlQueryReaderOptions & {
        limit?: number | "unbounded";
    }): ReturnType<ECSqlQueryExecutor["createQueryReader"]>;
}

// @beta
export type NodeParser = (row: {
    [columnName: string]: any;
}) => ParsedInstanceHierarchyNode;

// @beta
export type NodePostProcessor = (node: ProcessedHierarchyNode) => Promise<ProcessedHierarchyNode>;

// @beta
export type NodePreProcessor = <TNode extends ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode>(node: TNode) => Promise<TNode | undefined>;

// @beta
export enum NodeSelectClauseColumnNames {
    AutoExpand = "AutoExpand",
    DisplayLabel = "DisplayLabel",
    ECInstanceId = "ECInstanceId",
    ExtendedData = "ExtendedData",
    FullClassName = "FullClassName",
    Grouping = "Grouping",
    HasChildren = "HasChildren",
    HideIfNoChildren = "HideIfNoChildren",
    HideNodeInHierarchy = "HideNodeInHierarchy",
    SupportsFiltering = "SupportsFiltering"
}

// @beta
export interface NodesQueryClauseFactory {
    createFilterClauses(props: {
        contentClass: {
            fullName: string;
            alias: string;
        };
        filter: GenericInstanceFilter | undefined;
    }): Promise<{
        from: string;
        where: string;
        joins: string;
    }>;
    createSelectClause(props: NodeSelectClauseProps): Promise<string>;
}

// @beta
export interface NonGroupingHierarchyNode extends BaseHierarchyNode {
    key: string | InstancesNodeKey;
    supportsFiltering?: boolean;
}

// @beta
export type ParsedHierarchyNode<TBase = ParsedCustomHierarchyNode | ParsedInstanceHierarchyNode> = OmitOverUnion<TBase, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @beta
export type ProcessedHierarchyNode = ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode | ProcessedGroupingHierarchyNode;

// @beta
export class RowsLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @beta
export function setLogger(logger: ILogger | undefined): void;

// (No @packageDocumentation comment for this package)

```
