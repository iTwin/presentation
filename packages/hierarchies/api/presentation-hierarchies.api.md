## API Report File for "@itwin/presentation-hierarchies"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConcatenatedValue } from '@itwin/presentation-shared';
import { ECSqlQueryDef } from '@itwin/presentation-shared';
import { ECSqlQueryReader } from '@itwin/presentation-shared';
import { ECSqlQueryReaderOptions } from '@itwin/presentation-shared';
import { GenericInstanceFilter } from '@itwin/core-common';
import { GenericInstanceFilterRelatedInstanceDescription } from '@itwin/core-common';
import { GenericInstanceFilterRelationshipStep } from '@itwin/core-common';
import { GenericInstanceFilterRule } from '@itwin/core-common';
import { GenericInstanceFilterRuleGroup } from '@itwin/core-common';
import { GenericInstanceFilterRuleGroupOperator } from '@itwin/core-common';
import { GenericInstanceFilterRuleOperator } from '@itwin/core-common';
import { GenericInstanceFilterRuleValue } from '@itwin/core-common';
import { Id64String } from '@itwin/presentation-shared';
import { IECSqlQueryExecutor } from '@itwin/presentation-shared';
import { ILogger } from '@itwin/presentation-shared';
import { IMetadataProvider } from '@itwin/presentation-shared';
import { InstanceKey } from '@itwin/presentation-shared';
import { IPrimitiveValueFormatter } from '@itwin/presentation-shared';
import { OmitOverUnion } from '@itwin/presentation-shared';
import { PrimitiveValue } from '@itwin/presentation-shared';

// @beta
export interface BaseHierarchyNode {
    autoExpand?: boolean;
    children: boolean;
    extendedData?: {
        [key: string]: any;
    };
    label: string;
    parentKeys: HierarchyNodeKey[];
}

// @beta
export interface ClassBasedHierarchyDefinition {
    childNodes: Array<ClassBasedHierarchyLevelDefinition>;
    rootNodes: (props: DefineRootHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
}

// @beta
export interface ClassBasedHierarchyDefinitionsFactoryProps {
    hierarchy: ClassBasedHierarchyDefinition;
    metadataProvider: IMetadataProvider;
}

// @beta
export type ClassBasedHierarchyLevelDefinition = InstancesNodeChildHierarchyLevelDefinition | CustomNodeChildHierarchyLevelDefinition;

// @beta
export class ClassBasedHierarchyLevelDefinitionsFactory implements IHierarchyLevelDefinitionsFactory {
    constructor(props: ClassBasedHierarchyDefinitionsFactoryProps);
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
}

// @beta
export interface ClassGroupingNodeKey {
    className: string;
    type: "class-grouping";
}

// @beta
export function createLimitingECSqlQueryExecutor(baseExecutor: IECSqlQueryExecutor, defaultLimit: number | "unbounded"): ILimitingECSqlQueryExecutor;

// @beta
export interface CustomHierarchyNodeDefinition {
    node: ParsedCustomHierarchyNode;
}

// @beta
export interface CustomNodeChildHierarchyLevelDefinition {
    customParentNodeKey: string;
    definitions: (requestProps: DefineHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
}

// @beta
export interface DefineHierarchyLevelProps {
    instanceFilter?: GenericInstanceFilter;
    parentNode: HierarchyDefinitionParentNode | undefined;
}

// @beta
export type DefineInstanceNodeChildHierarchyLevelProps = DefineHierarchyLevelProps & {
    parentNodeInstanceIds: Id64String[];
    parentNode: HierarchyDefinitionParentNode;
};

// @beta
export type DefineRootHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode">;

// @beta
export interface ECSqlSelectClauseBaseClassGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    fullClassNames: string[] | ECSqlValueSelector[];
}

// @beta
export interface ECSqlSelectClauseGroupingParams {
    // (undocumented)
    byBaseClasses?: ECSqlSelectClauseBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | ECSqlSelectClauseGroupingParamsBase | ECSqlValueSelector;
    // (undocumented)
    byLabel?: ECSqlSelectClauseLabelGroupingParams;
    // (undocumented)
    byProperties?: ECSqlSelectClausePropertiesGroupingParams;
}

// @beta
export interface ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    autoExpand?: string | ECSqlValueSelector;
    // (undocumented)
    hideIfNoSiblings?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfOneGroupedNode?: boolean | ECSqlValueSelector;
}

// @beta
export interface ECSqlSelectClauseLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string | ECSqlValueSelector;
}

// @beta
export interface ECSqlSelectClauseLabelGroupingGroupParams extends ECSqlSelectClauseLabelGroupingBaseParams, ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @beta
export interface ECSqlSelectClauseLabelGroupingMergeParams extends ECSqlSelectClauseLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @beta
export type ECSqlSelectClauseLabelGroupingParams = boolean | ECSqlValueSelector | ECSqlSelectClauseLabelGroupingMergeParams | ECSqlSelectClauseLabelGroupingGroupParams;

// @beta
export interface ECSqlSelectClausePropertiesGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean | ECSqlValueSelector;
    createGroupForUnspecifiedValues?: boolean | ECSqlValueSelector;
    propertiesClassName: string;
    propertyGroups: Array<ECSqlSelectClausePropertyGroup>;
}

// @beta
export interface ECSqlSelectClausePropertyGroup {
    propertyClassAlias: string;
    propertyName: string;
    ranges?: Array<ECSqlSelectClausePropertyValueRange>;
}

// @beta
export interface ECSqlSelectClausePropertyValueRange {
    fromValue: number | ECSqlValueSelector;
    rangeLabel?: string | ECSqlValueSelector;
    toValue: number | ECSqlValueSelector;
}

// @beta
export interface ECSqlValueSelector {
    // (undocumented)
    selector: string;
}

export { GenericInstanceFilter }

export { GenericInstanceFilterRelatedInstanceDescription }

export { GenericInstanceFilterRelationshipStep }

export { GenericInstanceFilterRule }

export { GenericInstanceFilterRuleGroup }

export { GenericInstanceFilterRuleGroupOperator }

export { GenericInstanceFilterRuleOperator }

export { GenericInstanceFilterRuleValue }

// @beta
export interface GetHierarchyNodesProps {
    hierarchyLevelSizeLimit?: number | "unbounded";
    ignoreCache?: boolean;
    instanceFilter?: GenericInstanceFilter;
    parentNode: ParentHierarchyNode | undefined;
}

// @beta
export function getLogger(): ILogger;

// @beta
export interface GroupingHierarchyNode extends BaseHierarchyNode {
    groupedInstanceKeys: InstanceKey[];
    key: GroupingNodeKey;
    nonGroupingAncestor?: ParentHierarchyNode<NonGroupingHierarchyNode>;
}

// @beta
export type GroupingNodeKey = ClassGroupingNodeKey | LabelGroupingNodeKey | PropertyGroupingNodeKey;

// @beta
export type HierarchyDefinitionParentNode = Omit<HierarchyNode, "children" | "key"> & {
    key: InstancesNodeKey | string;
};

// @beta
export type HierarchyLevelDefinition = HierarchyNodesDefinition[];

// @beta
export type HierarchyNode = NonGroupingHierarchyNode | GroupingHierarchyNode;

// @beta (undocumented)
export namespace HierarchyNode {
    export function isClassGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: ClassGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isCustom<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & (TNode extends ProcessedHierarchyNode ? ProcessedCustomHierarchyNode : NonGroupingHierarchyNode) & {
        key: string;
    };
    export function isGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isInstancesNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & (TNode extends ProcessedHierarchyNode ? ProcessedInstanceHierarchyNode : NonGroupingHierarchyNode) & {
        key: InstancesNodeKey;
    };
    export function isLabelGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: LabelGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyOtherValuesGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyOtherValuesGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyValueGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isPropertyValueRangeGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueRangeGroupingNodeKey;
        supportsFiltering?: undefined;
    } & (TNode extends ProcessedHierarchyNode ? ProcessedGroupingHierarchyNode : GroupingHierarchyNode);
    export function isStandard<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: StandardHierarchyNodeKey;
    };
}

// @beta
export type HierarchyNodeAutoExpandProp = "single-child" | "always";

// @beta
export interface HierarchyNodeBaseClassGroupingParams extends HierarchyNodeGroupingParamsBase {
    fullClassNames: string[];
}

// @beta
export interface HierarchyNodeGroupingParams {
    // (undocumented)
    byBaseClasses?: HierarchyNodeBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | HierarchyNodeGroupingParamsBase;
    // (undocumented)
    byLabel?: HierarchyNodeLabelGroupingParams;
    // (undocumented)
    byProperties?: HierarchyNodePropertiesGroupingParams;
}

// @beta
export interface HierarchyNodeGroupingParamsBase {
    autoExpand?: HierarchyNodeAutoExpandProp;
    hideIfNoSiblings?: boolean;
    hideIfOneGroupedNode?: boolean;
}

// @beta
export type HierarchyNodeIdentifier = InstanceKey | {
    key: string;
};

// @beta (undocumented)
export namespace HierarchyNodeIdentifier {
    export function equal(lhs: HierarchyNodeIdentifier, rhs: HierarchyNodeIdentifier): boolean;
    export function isCustomNodeIdentifier(id: HierarchyNodeIdentifier): id is {
        key: string;
    };
    export function isInstanceNodeIdentifier(id: HierarchyNodeIdentifier): id is InstanceKey;
}

// @beta
export type HierarchyNodeIdentifiersPath = HierarchyNodeIdentifier[];

// @beta
export type HierarchyNodeKey = StandardHierarchyNodeKey | string;

// @beta (undocumented)
export namespace HierarchyNodeKey {
    export function compare(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): number;
    export function equals(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): boolean;
    export function isClassGrouping(key: HierarchyNodeKey): key is ClassGroupingNodeKey;
    export function isCustom(key: HierarchyNodeKey): key is string;
    export function isGrouping(key: HierarchyNodeKey): key is GroupingNodeKey;
    export function isInstances(key: HierarchyNodeKey): key is InstancesNodeKey;
    export function isLabelGrouping(key: HierarchyNodeKey): key is LabelGroupingNodeKey;
    export function isPropertyGrouping(key: HierarchyNodeKey): key is PropertyGroupingNodeKey;
    export function isPropertyOtherValuesGrouping(key: HierarchyNodeKey): key is PropertyOtherValuesGroupingNodeKey;
    export function isPropertyValueGrouping(key: HierarchyNodeKey): key is PropertyValueGroupingNodeKey;
    export function isPropertyValueRangeGrouping(key: HierarchyNodeKey): key is PropertyValueRangeGroupingNodeKey;
    export function isStandard(key: HierarchyNodeKey): key is StandardHierarchyNodeKey;
}

// @beta
export interface HierarchyNodeLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string;
}

// @beta
export interface HierarchyNodeLabelGroupingGroupParams extends HierarchyNodeLabelGroupingBaseParams, HierarchyNodeGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @beta
export interface HierarchyNodeLabelGroupingMergeParams extends HierarchyNodeLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @beta
export type HierarchyNodeLabelGroupingParams = boolean | HierarchyNodeLabelGroupingMergeParams | HierarchyNodeLabelGroupingGroupParams;

// @beta
export interface HierarchyNodeProcessingParamsBase {
    hideIfNoChildren?: boolean;
    hideInHierarchy?: boolean;
}

// @beta
export interface HierarchyNodePropertiesGroupingParams extends HierarchyNodeGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    propertiesClassName: string;
    propertyGroups: Array<HierarchyNodePropertyGroup>;
}

// @beta
export interface HierarchyNodePropertyGroup {
    propertyName: string;
    propertyValue?: PrimitiveValue;
    ranges?: Array<HierarchyNodePropertyValueRange>;
}

// @beta
export interface HierarchyNodePropertyValueRange {
    fromValue: number;
    rangeLabel?: string;
    toValue: number;
}

// @beta
export type HierarchyNodesDefinition = CustomHierarchyNodeDefinition | InstanceNodesQueryDefinition;

// @beta (undocumented)
export namespace HierarchyNodesDefinition {
    // (undocumented)
    export function isCustomNode(def: HierarchyNodesDefinition): def is CustomHierarchyNodeDefinition;
    // (undocumented)
    export function isInstanceNodesQuery(def: HierarchyNodesDefinition): def is InstanceNodesQueryDefinition;
}

// @beta
export class HierarchyProvider {
    constructor(props: HierarchyProviderProps);
    getNodeInstanceKeys(props: {
        parentNode: ParentHierarchyNode | undefined;
    }): AsyncIterableIterator<InstanceKey>;
    getNodes(props: GetHierarchyNodesProps): AsyncIterableIterator<HierarchyNode>;
    readonly hierarchyDefinition: IHierarchyLevelDefinitionsFactory;
    notifyDataSourceChanged(): void;
    readonly queryExecutor: ILimitingECSqlQueryExecutor;
    // @internal (undocumented)
    get queryScheduler(): {
        schedule: ILimitingECSqlQueryExecutor["createQueryReader"];
    };
    setFormatter(formatter: IPrimitiveValueFormatter | undefined): void;
}

// @beta
export interface HierarchyProviderLocalizedStrings {
    other: string;
    unspecified: string;
}

// @beta
export interface HierarchyProviderProps {
    filtering?: {
        paths: HierarchyNodeIdentifiersPath[];
    };
    formatter?: IPrimitiveValueFormatter;
    hierarchyDefinition: IHierarchyLevelDefinitionsFactory;
    localizedStrings?: HierarchyProviderLocalizedStrings;
    metadataProvider: IMetadataProvider;
    queryCacheSize?: number;
    queryConcurrency?: number;
    queryExecutor: ILimitingECSqlQueryExecutor;
}

// @beta
export interface IHierarchyLevelDefinitionsFactory {
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
    parseNode?: INodeParser;
    postProcessNode?: INodePostProcessor;
    preProcessNode?: INodePreProcessor;
}

// @beta
export interface ILimitingECSqlQueryExecutor {
    createQueryReader(query: ECSqlQueryDef, config?: ECSqlQueryReaderOptions & {
        limit?: number | "unbounded";
    }): ECSqlQueryReader;
}

// @beta
export type INodeParser = (row: {
    [columnName: string]: any;
}) => ParsedInstanceHierarchyNode;

// @beta
export type INodePostProcessor = (node: ProcessedHierarchyNode) => Promise<ProcessedHierarchyNode>;

// @beta
export type INodePreProcessor = <TNode extends ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode>(node: TNode) => Promise<TNode | undefined>;

// @beta
export interface InstanceHierarchyNodeProcessingParams extends HierarchyNodeProcessingParamsBase {
    // (undocumented)
    grouping?: HierarchyNodeGroupingParams;
}

// @beta
export interface InstanceNodesQueryDefinition {
    fullClassName: string;
    query: ECSqlQueryDef;
}

// @beta
export interface InstancesNodeChildHierarchyLevelDefinition {
    definitions: (requestProps: DefineInstanceNodeChildHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
    parentNodeClassName: string;
}

// @beta
export interface InstancesNodeKey {
    instanceKeys: InstanceKey[];
    type: "instances";
}

// @beta
export interface LabelGroupingNodeKey {
    groupId?: string;
    label: string;
    type: "label-grouping";
}

// @beta
export enum NodeSelectClauseColumnNames {
    AutoExpand = "AutoExpand",
    DisplayLabel = "DisplayLabel",
    ECInstanceId = "ECInstanceId",
    ExtendedData = "ExtendedData",
    FullClassName = "FullClassName",
    Grouping = "Grouping",
    HasChildren = "HasChildren",
    HideIfNoChildren = "HideIfNoChildren",
    HideNodeInHierarchy = "HideNodeInHierarchy",
    SupportsFiltering = "SupportsFiltering"
}

// @beta
export interface NodeSelectClauseProps {
    // (undocumented)
    autoExpand?: boolean | ECSqlValueSelector;
    // (undocumented)
    ecClassId: Id64String | ECSqlValueSelector;
    // (undocumented)
    ecInstanceId: Id64String | ECSqlValueSelector;
    // (undocumented)
    extendedData?: {
        [key: string]: Id64String | string | number | boolean | ECSqlValueSelector;
    };
    // (undocumented)
    grouping?: ECSqlSelectClauseGroupingParams;
    // (undocumented)
    hasChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfNoChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideNodeInHierarchy?: boolean | ECSqlValueSelector;
    // (undocumented)
    nodeLabel: string | ECSqlValueSelector;
    // (undocumented)
    supportsFiltering?: boolean | ECSqlValueSelector;
}

// @beta
export class NodeSelectQueryFactory {
    constructor(_metadataProvider: IMetadataProvider);
    createFilterClauses(def: GenericInstanceFilter | undefined, contentClass: {
        fullName: string;
        alias: string;
    }): Promise<{
        from: string;
        where: string;
        joins: string;
    }>;
    createSelectClause(props: NodeSelectClauseProps): Promise<string>;
}

// @beta
export interface NonGroupingHierarchyNode extends BaseHierarchyNode {
    key: string | InstancesNodeKey;
    supportsFiltering?: boolean;
}

// @beta
export type ParentHierarchyNode<TBase = HierarchyNode> = OmitOverUnion<TBase, "children">;

// @beta
export type ParsedCustomHierarchyNode = Omit<ProcessedCustomHierarchyNode, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @beta
export type ParsedHierarchyNode = ParsedCustomHierarchyNode | ParsedInstanceHierarchyNode;

// @beta
export type ParsedInstanceHierarchyNode = Omit<ProcessedInstanceHierarchyNode, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @beta
export type ProcessedCustomHierarchyNode = Omit<NonGroupingHierarchyNode, "key" | "children"> & {
    key: string;
    children?: boolean;
    processingParams?: HierarchyNodeProcessingParamsBase;
};

// @beta
export type ProcessedGroupingHierarchyNode = Omit<GroupingHierarchyNode, "children"> & {
    children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
};

// @beta
export type ProcessedHierarchyNode = ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode | ProcessedGroupingHierarchyNode;

// @beta
export type ProcessedInstanceHierarchyNode = Omit<NonGroupingHierarchyNode, "key" | "children"> & {
    key: InstancesNodeKey;
    children?: boolean;
    processingParams?: InstanceHierarchyNodeProcessingParams;
};

// @beta
export type PropertyGroupingNodeKey = PropertyValueRangeGroupingNodeKey | PropertyValueGroupingNodeKey | PropertyOtherValuesGroupingNodeKey;

// @beta
export interface PropertyOtherValuesGroupingNodeKey {
    properties: Array<{
        className: string;
        propertyName: string;
    }>;
    type: "property-grouping:other";
}

// @beta
export interface PropertyValueGroupingNodeKey {
    formattedPropertyValue: string;
    propertyClassName: string;
    propertyName: string;
    type: "property-grouping:value";
}

// @beta
export interface PropertyValueRangeGroupingNodeKey {
    fromValue: number;
    propertyClassName: string;
    propertyName: string;
    toValue: number;
    type: "property-grouping:range";
}

// @beta
export class RowsLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @beta
export function setLogger(logger: ILogger | undefined): void;

// @beta
export type StandardHierarchyNodeKey = InstancesNodeKey | GroupingNodeKey;

// (No @packageDocumentation comment for this package)

```
