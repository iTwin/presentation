## API Report File for "@itwin/presentation-hierarchies"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConcatenatedValue } from '@itwin/presentation-shared';
import { ECClassHierarchyInspector } from '@itwin/presentation-shared';
import { ECSchemaProvider } from '@itwin/presentation-shared';
import { ECSqlQueryDef } from '@itwin/presentation-shared';
import { ECSqlQueryExecutor } from '@itwin/presentation-shared';
import { ECSqlQueryReaderOptions } from '@itwin/presentation-shared';
import { Event as Event_2 } from '@itwin/presentation-shared';
import { GenericInstanceFilter } from '@itwin/core-common';
import { Id64String } from '@itwin/core-bentley';
import { IInstanceLabelSelectClauseFactory } from '@itwin/presentation-shared';
import { ILogger } from '@itwin/presentation-shared';
import { InstanceKey } from '@itwin/presentation-shared';
import { IPrimitiveValueFormatter } from '@itwin/presentation-shared';
import { OmitOverUnion } from '@itwin/presentation-shared';
import { PrimitiveValue } from '@itwin/presentation-shared';

// @beta
interface BaseHierarchyNode {
    autoExpand?: boolean;
    children: boolean;
    extendedData?: {
        [key: string]: any;
    };
    filtering?: HierarchyNodeFilteringProps;
    label: string;
    parentKeys: HierarchyNodeKey[];
}

// @beta
interface ClassBasedHierarchyDefinitionProps {
    classHierarchyInspector: ECClassHierarchyInspector;
    hierarchy: {
        rootNodes: (props: DefineRootHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
        childNodes: ClassBasedHierarchyLevelDefinition[];
    };
}

// @beta
type ClassBasedHierarchyLevelDefinition = InstancesNodeChildHierarchyLevelDefinition | CustomNodeChildHierarchyLevelDefinition;

// @beta
export interface ClassGroupingNodeKey {
    className: string;
    type: "class-grouping";
}

// @beta
export function createClassBasedHierarchyDefinition(props: ClassBasedHierarchyDefinitionProps): HierarchyDefinition;

// @beta
export function createIModelHierarchyProvider(props: IModelHierarchyProviderProps): HierarchyProvider & {
    dispose: () => void;
};

// @beta
export function createLimitingECSqlQueryExecutor(baseExecutor: ECSqlQueryExecutor, defaultLimit: number | "unbounded"): LimitingECSqlQueryExecutor;

// @beta
export function createNodesQueryClauseFactory(props: {
    imodelAccess: ECSchemaProvider & ECClassHierarchyInspector;
    instanceLabelSelectClauseFactory: IInstanceLabelSelectClauseFactory;
}): NodesQueryClauseFactory;

// @beta
interface CustomHierarchyNodeDefinition {
    node: ParsedCustomHierarchyNode;
}

// @beta
interface CustomNodeChildHierarchyLevelDefinition {
    customParentNodeKey: string;
    definitions: (requestProps: DefineCustomNodeChildHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
}

// @beta
export type DefineCustomNodeChildHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode"> & {
    parentNode: Omit<HierarchyDefinitionParentNode, "key"> & {
        key: string;
    };
};

// @beta
export interface DefineHierarchyLevelProps {
    instanceFilter?: GenericInstanceFilter;
    parentNode: HierarchyDefinitionParentNode | undefined;
}

// @beta
export type DefineInstanceNodeChildHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode"> & {
    parentNode: Omit<HierarchyDefinitionParentNode, "key"> & {
        key: InstancesNodeKey;
    };
    parentNodeClassName: string;
    parentNodeInstanceIds: Id64String[];
};

// @beta
export type DefineRootHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode">;

// @beta
interface ECSqlSelectClauseBaseClassGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    fullClassNames: string[] | ECSqlValueSelector[];
}

// @beta
interface ECSqlSelectClauseGroupingParams {
    // (undocumented)
    byBaseClasses?: ECSqlSelectClauseBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | ECSqlSelectClauseGroupingParamsBase | ECSqlValueSelector;
    // (undocumented)
    byLabel?: ECSqlSelectClauseLabelGroupingParams;
    // (undocumented)
    byProperties?: ECSqlSelectClausePropertiesGroupingParams;
}

// @beta
interface ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    autoExpand?: HierarchyNodeAutoExpandProp | ECSqlValueSelector;
    // (undocumented)
    hideIfNoSiblings?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfOneGroupedNode?: boolean | ECSqlValueSelector;
}

// @beta
interface ECSqlSelectClauseLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string | ECSqlValueSelector;
}

// @beta
interface ECSqlSelectClauseLabelGroupingGroupParams extends ECSqlSelectClauseLabelGroupingBaseParams, ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @beta
interface ECSqlSelectClauseLabelGroupingMergeParams extends ECSqlSelectClauseLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @beta
type ECSqlSelectClauseLabelGroupingParams = boolean | ECSqlValueSelector | ECSqlSelectClauseLabelGroupingMergeParams | ECSqlSelectClauseLabelGroupingGroupParams;

// @beta
interface ECSqlSelectClausePropertiesGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean | ECSqlValueSelector;
    createGroupForUnspecifiedValues?: boolean | ECSqlValueSelector;
    propertiesClassName: string;
    propertyGroups: ECSqlSelectClausePropertyGroup[];
}

// @beta
interface ECSqlSelectClausePropertyGroup {
    propertyClassAlias: string;
    propertyName: string;
    ranges?: ECSqlSelectClausePropertyValueRange[];
}

// @beta
interface ECSqlSelectClausePropertyValueRange {
    fromValue: number | ECSqlValueSelector;
    rangeLabel?: string | ECSqlValueSelector;
    toValue: number | ECSqlValueSelector;
}

// @beta
interface ECSqlValueSelector {
    // (undocumented)
    selector: string;
}

// @beta (undocumented)
interface FilterTargetGroupingNodeInfo {
    depth: number;
    key: GroupingNodeKey;
}

export { GenericInstanceFilter }

// @beta
export interface GetHierarchyNodesProps {
    hierarchyLevelSizeLimit?: number | "unbounded";
    ignoreCache?: boolean;
    instanceFilter?: GenericInstanceFilter;
    parentNode: ParentHierarchyNode | undefined;
}

// @beta
export function getLogger(): ILogger;

// @beta
export interface GroupingHierarchyNode extends BaseHierarchyNode {
    groupedInstanceKeys: InstanceKey[];
    key: GroupingNodeKey;
    nonGroupingAncestor?: ParentHierarchyNode<NonGroupingHierarchyNode>;
}

// @beta
export type GroupingNodeKey = ClassGroupingNodeKey | LabelGroupingNodeKey | PropertyGroupingNodeKey;

// @beta
export interface HierarchyDefinition {
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
    parseNode?: NodeParser;
    postProcessNode?: NodePostProcessor;
    preProcessNode?: NodePreProcessor;
}

// @beta
type HierarchyDefinitionParentNode = Omit<NonGroupingHierarchyNode, "children">;

// @beta
type HierarchyFilteringPath = HierarchyNodeIdentifiersPath | {
    path: HierarchyNodeIdentifiersPath;
    options: HierarchyFilteringPathOptions;
};

// @beta (undocumented)
interface HierarchyFilteringPathOptions {
    autoExpand?: boolean | FilterTargetGroupingNodeInfo;
}

// @beta
export type HierarchyLevelDefinition = HierarchyNodesDefinition[];

// @beta
export type HierarchyNode = NonGroupingHierarchyNode | GroupingHierarchyNode;

// @beta (undocumented)
export namespace HierarchyNode {
    export function isClassGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: ClassGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isCustom<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & NonGroupingHierarchyNode & {
        key: string;
    };
    export function isGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & GroupingHierarchyNode;
    export function isInstancesNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    export function isLabelGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: LabelGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyOtherValuesGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyOtherValuesGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyValueGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyValueRangeGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueRangeGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isStandard<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: StandardHierarchyNodeKey;
    };
}

// @beta
type HierarchyNodeAutoExpandProp = "single-child" | "always";

// @beta
interface HierarchyNodeBaseClassGroupingParams extends HierarchyNodeGroupingParamsBase {
    fullClassNames: string[];
}

// @beta (undocumented)
type HierarchyNodeFilteringProps = {
    hasFilterTargetAncestor?: boolean;
    filteredChildrenIdentifierPaths?: HierarchyFilteringPath[];
} & ({
    isFilterTarget?: false;
} | {
    isFilterTarget: true;
    filterTargetOptions?: HierarchyFilteringPathOptions;
});

// @beta
interface HierarchyNodeGroupingParams {
    // (undocumented)
    byBaseClasses?: HierarchyNodeBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | HierarchyNodeGroupingParamsBase;
    // (undocumented)
    byLabel?: HierarchyNodeLabelGroupingParams;
    // (undocumented)
    byProperties?: HierarchyNodePropertiesGroupingParams;
}

// @beta
interface HierarchyNodeGroupingParamsBase {
    autoExpand?: HierarchyNodeAutoExpandProp;
    hideIfNoSiblings?: boolean;
    hideIfOneGroupedNode?: boolean;
}

// @beta
export type HierarchyNodeIdentifier = InstanceKey | {
    key: string;
};

// @beta (undocumented)
export namespace HierarchyNodeIdentifier {
    export function equal(lhs: HierarchyNodeIdentifier, rhs: HierarchyNodeIdentifier): boolean;
    export function isCustomNodeIdentifier(id: HierarchyNodeIdentifier): id is {
        key: string;
    };
    export function isInstanceNodeIdentifier(id: HierarchyNodeIdentifier): id is InstanceKey;
}

// @beta
export type HierarchyNodeIdentifiersPath = HierarchyNodeIdentifier[];

// @beta
export type HierarchyNodeKey = StandardHierarchyNodeKey | string;

// @beta (undocumented)
export namespace HierarchyNodeKey {
    export function compare(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): number;
    export function equals(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): boolean;
    export function isClassGrouping(key: HierarchyNodeKey): key is ClassGroupingNodeKey;
    export function isCustom(key: HierarchyNodeKey): key is string;
    export function isGrouping(key: HierarchyNodeKey): key is GroupingNodeKey;
    export function isInstances(key: HierarchyNodeKey): key is InstancesNodeKey;
    export function isLabelGrouping(key: HierarchyNodeKey): key is LabelGroupingNodeKey;
    export function isPropertyGrouping(key: HierarchyNodeKey): key is PropertyGroupingNodeKey;
    export function isPropertyOtherValuesGrouping(key: HierarchyNodeKey): key is PropertyOtherValuesGroupingNodeKey;
    export function isPropertyValueGrouping(key: HierarchyNodeKey): key is PropertyValueGroupingNodeKey;
    export function isPropertyValueRangeGrouping(key: HierarchyNodeKey): key is PropertyValueRangeGroupingNodeKey;
    export function isStandard(key: HierarchyNodeKey): key is StandardHierarchyNodeKey;
}

// @beta
interface HierarchyNodeLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string;
}

// @beta
interface HierarchyNodeLabelGroupingGroupParams extends HierarchyNodeLabelGroupingBaseParams, HierarchyNodeGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @beta
interface HierarchyNodeLabelGroupingMergeParams extends HierarchyNodeLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @beta
type HierarchyNodeLabelGroupingParams = boolean | HierarchyNodeLabelGroupingMergeParams | HierarchyNodeLabelGroupingGroupParams;

// @beta
interface HierarchyNodeProcessingParamsBase {
    hideIfNoChildren?: boolean;
    hideInHierarchy?: boolean;
}

// @beta
interface HierarchyNodePropertiesGroupingParams extends HierarchyNodeGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    propertiesClassName: string;
    propertyGroups: HierarchyNodePropertyGroup[];
}

// @beta
interface HierarchyNodePropertyGroup {
    propertyName: string;
    propertyValue?: PrimitiveValue | ConcatenatedValue;
    ranges?: HierarchyNodePropertyValueRange[];
}

// @beta
interface HierarchyNodePropertyValueRange {
    fromValue: number;
    rangeLabel?: string;
    toValue: number;
}

// @beta
export type HierarchyNodesDefinition = CustomHierarchyNodeDefinition | InstanceNodesQueryDefinition;

// @beta (undocumented)
export namespace HierarchyNodesDefinition {
    // (undocumented)
    export function isCustomNode(def: HierarchyNodesDefinition): def is CustomHierarchyNodeDefinition;
    // (undocumented)
    export function isInstanceNodesQuery(def: HierarchyNodesDefinition): def is InstanceNodesQueryDefinition;
}

// @beta
export interface HierarchyProvider {
    getNodeInstanceKeys(props: Omit<GetHierarchyNodesProps, "ignoreCache">): AsyncIterableIterator<InstanceKey>;
    getNodes(props: GetHierarchyNodesProps): AsyncIterableIterator<HierarchyNode>;
    setFormatter(formatter: IPrimitiveValueFormatter | undefined): void;
    setHierarchyFilter(props: {
        paths: HierarchyFilteringPath[];
    } | undefined): void;
}

// @beta (undocumented)
type IModelAccess = ECSchemaProvider & LimitingECSqlQueryExecutor & ECClassHierarchyInspector & {
    imodelKey: string;
};

// @beta
interface IModelHierarchyProviderLocalizedStrings {
    other: string;
    unspecified: string;
}

// @beta
interface IModelHierarchyProviderProps {
    filtering?: {
        paths: HierarchyFilteringPath[];
    };
    formatter?: IPrimitiveValueFormatter;
    hierarchyDefinition: HierarchyDefinition;
    imodelAccess: IModelAccess;
    imodelChanged?: Event_2<() => void>;
    localizedStrings?: Partial<IModelHierarchyProviderLocalizedStrings>;
    queryCacheSize?: number;
    queryConcurrency?: number;
}

// @beta
interface InstanceHierarchyNodeProcessingParams extends HierarchyNodeProcessingParamsBase {
    // (undocumented)
    grouping?: HierarchyNodeGroupingParams;
}

// @beta
interface InstanceNodesQueryDefinition {
    fullClassName: string;
    query: ECSqlQueryDef;
}

// @beta
interface InstancesNodeChildHierarchyLevelDefinition {
    definitions: (requestProps: DefineInstanceNodeChildHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
    onlyIfNotHandled?: boolean;
    parentNodeClassName: string;
}

// @beta
export interface InstancesNodeKey {
    instanceKeys: InstanceKey[];
    type: "instances";
}

// @beta
export interface LabelGroupingNodeKey {
    groupId?: string;
    label: string;
    type: "label-grouping";
}

// @beta
export interface LimitingECSqlQueryExecutor {
    createQueryReader(query: ECSqlQueryDef, config?: ECSqlQueryReaderOptions & {
        limit?: number | "unbounded";
    }): ReturnType<ECSqlQueryExecutor["createQueryReader"]>;
}

// @beta (undocumented)
interface MergeHierarchyProvidersProps {
    // (undocumented)
    providers: HierarchyProvider[];
}

// @beta (undocumented)
export function mergeProviders({ providers }: MergeHierarchyProvidersProps): HierarchyProvider & {
    dispose: () => void;
};

// @beta
export type NodeParser = (row: {
    [columnName: string]: any;
}) => ParsedInstanceHierarchyNode;

// @beta
export type NodePostProcessor = (node: ProcessedHierarchyNode) => Promise<ProcessedHierarchyNode>;

// @beta
export type NodePreProcessor = <TNode extends ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode>(node: TNode) => Promise<TNode | undefined>;

// @beta
export enum NodeSelectClauseColumnNames {
    AutoExpand = "AutoExpand",
    DisplayLabel = "DisplayLabel",
    ECInstanceId = "ECInstanceId",
    ExtendedData = "ExtendedData",
    FullClassName = "FullClassName",
    Grouping = "Grouping",
    HasChildren = "HasChildren",
    HideIfNoChildren = "HideIfNoChildren",
    HideNodeInHierarchy = "HideNodeInHierarchy",
    SupportsFiltering = "SupportsFiltering"
}

// @beta
interface NodeSelectClauseProps {
    // (undocumented)
    autoExpand?: boolean | ECSqlValueSelector;
    // (undocumented)
    ecClassId: ECSqlValueSelector;
    // (undocumented)
    ecInstanceId: ECSqlValueSelector;
    // (undocumented)
    extendedData?: {
        [key: string]: Id64String | string | number | boolean | ECSqlValueSelector;
    };
    // (undocumented)
    grouping?: ECSqlSelectClauseGroupingParams;
    // (undocumented)
    hasChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfNoChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideNodeInHierarchy?: boolean | ECSqlValueSelector;
    // (undocumented)
    nodeLabel: string | ECSqlValueSelector;
    // (undocumented)
    supportsFiltering?: boolean | ECSqlValueSelector;
}

// @beta
export interface NodesQueryClauseFactory {
    createFilterClauses(props: {
        contentClass: {
            fullName: string;
            alias: string;
        };
        filter: GenericInstanceFilter | undefined;
    }): Promise<{
        from: string;
        where: string;
        joins: string;
    }>;
    createSelectClause(props: NodeSelectClauseProps): Promise<string>;
}

// @beta
export interface NonGroupingHierarchyNode extends BaseHierarchyNode {
    key: string | InstancesNodeKey;
    supportsFiltering?: boolean;
}

// @beta
type ParentHierarchyNode<TBase = HierarchyNode> = OmitOverUnion<TBase, "children">;

// @beta
type ParsedCustomHierarchyNode = ParsedHierarchyNode<ProcessedCustomHierarchyNode>;

// @beta
export type ParsedHierarchyNode<TBase = ParsedCustomHierarchyNode | ParsedInstanceHierarchyNode> = OmitOverUnion<TBase, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @beta
type ParsedInstanceHierarchyNode = ParsedHierarchyNode<ProcessedInstanceHierarchyNode>;

// @beta
type ProcessedCustomHierarchyNode = Omit<NonGroupingHierarchyNode, "key" | "children"> & {
    key: string;
    children?: boolean;
    processingParams?: HierarchyNodeProcessingParamsBase;
};

// @beta
type ProcessedGroupingHierarchyNode = Omit<GroupingHierarchyNode, "children"> & {
    children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
};

// @beta
export type ProcessedHierarchyNode = ProcessedCustomHierarchyNode | ProcessedInstanceHierarchyNode | ProcessedGroupingHierarchyNode;

// @beta (undocumented)
export namespace ProcessedHierarchyNode {
    export function isCustom(node: ProcessedHierarchyNode): node is ProcessedCustomHierarchyNode;
    export function isGroupingNode(node: ProcessedHierarchyNode): node is ProcessedGroupingHierarchyNode;
    export function isInstancesNode(node: ProcessedHierarchyNode): node is ProcessedInstanceHierarchyNode;
}

// @beta
type ProcessedInstanceHierarchyNode = Omit<NonGroupingHierarchyNode, "key" | "children"> & {
    key: InstancesNodeKey;
    children?: boolean;
    processingParams?: InstanceHierarchyNodeProcessingParams;
};

// @beta
export type PropertyGroupingNodeKey = PropertyValueRangeGroupingNodeKey | PropertyValueGroupingNodeKey | PropertyOtherValuesGroupingNodeKey;

// @beta
export interface PropertyOtherValuesGroupingNodeKey {
    properties: Array<{
        className: string;
        propertyName: string;
    }>;
    type: "property-grouping:other";
}

// @beta
export interface PropertyValueGroupingNodeKey {
    formattedPropertyValue: string;
    propertyClassName: string;
    propertyName: string;
    type: "property-grouping:value";
}

// @beta
export interface PropertyValueRangeGroupingNodeKey {
    fromValue: number;
    propertyClassName: string;
    propertyName: string;
    toValue: number;
    type: "property-grouping:range";
}

// @beta
export class RowsLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @beta
export function setLogger(logger: ILogger | undefined): void;

// @beta
export type StandardHierarchyNodeKey = InstancesNodeKey | GroupingNodeKey;

// (No @packageDocumentation comment for this package)

```
