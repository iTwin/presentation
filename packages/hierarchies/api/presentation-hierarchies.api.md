## API Report File for "@itwin/presentation-hierarchies"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConcatenatedValue } from '@itwin/presentation-shared';
import { ECClassHierarchyInspector } from '@itwin/presentation-shared';
import { ECSchemaProvider } from '@itwin/presentation-shared';
import { ECSqlQueryDef } from '@itwin/presentation-shared';
import { ECSqlQueryExecutor } from '@itwin/presentation-shared';
import { ECSqlQueryReaderOptions } from '@itwin/presentation-shared';
import { Event as Event_2 } from '@itwin/presentation-shared';
import { GenericInstanceFilter } from '@itwin/core-common';
import { Id64String } from '@itwin/core-bentley';
import { IInstanceLabelSelectClauseFactory } from '@itwin/presentation-shared';
import { ILogger } from '@itwin/presentation-shared';
import { InstanceKey } from '@itwin/presentation-shared';
import { IPrimitiveValueFormatter } from '@itwin/presentation-shared';
import { OmitOverUnion } from '@itwin/presentation-shared';
import { PrimitiveValue } from '@itwin/presentation-shared';
import { Props } from '@itwin/presentation-shared';

// @public
interface BaseHierarchyNode {
    autoExpand?: boolean;
    children: boolean;
    extendedData?: {
        [key: string]: any;
    };
    filtering?: HierarchyNodeFilteringProps;
    label: string;
    parentKeys: HierarchyNodeKey[];
}

// @public
export interface ClassGroupingNodeKey {
    className: string;
    type: "class-grouping";
}

// @public
export function createHierarchyFilteringHelper(rootLevelFilteringProps: HierarchyFilteringPath[] | undefined, parentNode: Pick<NonGroupingHierarchyNode, "filtering"> | undefined): {
    hasFilter: boolean;
    hasFilterTargetAncestor: boolean;
    getChildNodeFilteringIdentifiers: () => HierarchyNodeIdentifier[] | undefined;
    createChildNodeProps: (props: {
        parentNode?: ParentHierarchyNode;
    } & ({
        nodeKey: InstancesNodeKey | GenericNodeKey;
    } | {
        pathMatcher: (identifier: HierarchyNodeIdentifier) => boolean;
    })) => NodeProps | undefined;
    createChildNodePropsAsync: (props: {
        parentNode?: HierarchyDefinitionParentNode;
        pathMatcher: (identifier: HierarchyNodeIdentifier) => boolean | Promise<boolean>;
    }) => Promise<NodeProps | undefined> | NodeProps | undefined;
};

// @public
export function createIModelHierarchyProvider(props: IModelHierarchyProviderProps): HierarchyProvider & {
    dispose: () => void;
    [Symbol.dispose]: () => void;
};

// @public
export function createLimitingECSqlQueryExecutor(baseExecutor: ECSqlQueryExecutor, defaultLimit: number | "unbounded"): LimitingECSqlQueryExecutor;

// @public
export function createNodesQueryClauseFactory(props: {
    imodelAccess: ECSchemaProvider & ECClassHierarchyInspector;
    instanceLabelSelectClauseFactory: IInstanceLabelSelectClauseFactory;
}): NodesQueryClauseFactory;

// @public
export function createPredicateBasedHierarchyDefinition(props: PredicateBasedHierarchyDefinitionProps): HierarchyDefinition;

// @public
export type DefineGenericNodeChildHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode"> & {
    parentNode: Omit<HierarchyDefinitionParentNode, "key"> & {
        key: GenericNodeKey;
    };
};

// @public
export interface DefineHierarchyLevelProps {
    instanceFilter?: GenericInstanceFilter;
    parentNode: HierarchyDefinitionParentNode | undefined;
}

// @public
export type DefineInstanceNodeChildHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode"> & {
    parentNode: Omit<HierarchyDefinitionParentNode, "key"> & {
        key: InstancesNodeKey;
    };
    parentNodeClassName: string;
    parentNodeInstanceIds: Id64String[];
};

// @public
export type DefineRootHierarchyLevelProps = Omit<DefineHierarchyLevelProps, "parentNode">;

// @public
interface ECSqlSelectClauseBaseClassGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    fullClassNames: string[] | ECSqlValueSelector[];
}

// @public
interface ECSqlSelectClauseGroupingParams {
    // (undocumented)
    byBaseClasses?: ECSqlSelectClauseBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | ECSqlSelectClauseGroupingParamsBase | ECSqlValueSelector;
    // (undocumented)
    byLabel?: ECSqlSelectClauseLabelGroupingParams;
    // (undocumented)
    byProperties?: ECSqlSelectClausePropertiesGroupingParams;
}

// @public
interface ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    autoExpand?: HierarchyNodeAutoExpandProp | ECSqlValueSelector;
    // (undocumented)
    hideIfNoSiblings?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfOneGroupedNode?: boolean | ECSqlValueSelector;
}

// @public
interface ECSqlSelectClauseLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string | ECSqlValueSelector;
}

// @public
interface ECSqlSelectClauseLabelGroupingGroupParams extends ECSqlSelectClauseLabelGroupingBaseParams, ECSqlSelectClauseGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @public
interface ECSqlSelectClauseLabelGroupingMergeParams extends ECSqlSelectClauseLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @public
type ECSqlSelectClauseLabelGroupingParams = boolean | ECSqlValueSelector | ECSqlSelectClauseLabelGroupingMergeParams | ECSqlSelectClauseLabelGroupingGroupParams;

// @public
interface ECSqlSelectClausePropertiesGroupingParams extends ECSqlSelectClauseGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean | ECSqlValueSelector;
    createGroupForUnspecifiedValues?: boolean | ECSqlValueSelector;
    propertiesClassName: string;
    propertyGroups: ECSqlSelectClausePropertyGroup[];
}

// @public
interface ECSqlSelectClausePropertyGroup {
    propertyClassAlias: string;
    propertyName: string;
    ranges?: ECSqlSelectClausePropertyValueRange[];
}

// @public
interface ECSqlSelectClausePropertyValueRange {
    fromValue: number | ECSqlValueSelector;
    rangeLabel?: string | ECSqlValueSelector;
    toValue: number | ECSqlValueSelector;
}

// @public
interface ECSqlValueSelector {
    // (undocumented)
    selector: string;
}

// @public @deprecated
export function extractFilteringProps(rootLevelFilteringProps: HierarchyFilteringPath[], parentNode: Pick<NonGroupingHierarchyNode, "filtering"> | undefined): {
    filteredNodePaths: HierarchyFilteringPath[];
    hasFilterTargetAncestor: boolean;
} | undefined;

// @public (undocumented)
interface FilteringPathAutoExpandDepthInHierarchy {
    depthInHierarchy: number;
}

// @public (undocumented)
interface FilteringPathAutoExpandDepthInPath {
    depthInPath: number;
}

// @public @deprecated (undocumented)
interface FilteringPathAutoExpandOption {
    // @deprecated
    depth: number;
    // @deprecated
    includeGroupingNodes?: boolean;
}

// @public @deprecated (undocumented)
interface FilterTargetGroupingNodeInfo {
    // @deprecated
    depth: number;
    // @deprecated
    key: GroupingNodeKey;
}

// @public
interface GenericHierarchyNodeDefinition {
    node: SourceGenericHierarchyNode;
}

export { GenericInstanceFilter }

// @public
interface GenericNodeChildHierarchyLevelDefinition {
    definitions: (requestProps: DefineGenericNodeChildHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
    parentGenericNodePredicate: (parentNodeKey: GenericNodeKey) => Promise<boolean>;
}

// @public
export interface GenericNodeKey {
    id: string;
    source?: string;
    type: "generic";
}

// @public
export interface GetHierarchyNodesProps {
    hierarchyLevelSizeLimit?: number | "unbounded";
    ignoreCache?: boolean;
    instanceFilter?: GenericInstanceFilter;
    parentNode: ParentHierarchyNode | undefined;
}

// @public
export function getLogger(): ILogger;

// @public
export interface GroupingHierarchyNode extends BaseHierarchyNode {
    groupedInstanceKeys: IModelInstanceKey[];
    key: GroupingNodeKey;
    nonGroupingAncestor?: ParentHierarchyNode<NonGroupingHierarchyNode>;
}

// @public
export type GroupingNodeKey = ClassGroupingNodeKey | LabelGroupingNodeKey | PropertyGroupingNodeKey;

// @public
interface HierarchyChangedEventArgs {
    filterChange?: {
        newFilter: Props<HierarchyProvider["setHierarchyFilter"]>;
    };
    formatterChange?: {
        newFormatter: IPrimitiveValueFormatter | undefined;
    };
}

// @public
export interface HierarchyDefinition {
    defineHierarchyLevel(props: DefineHierarchyLevelProps): Promise<HierarchyLevelDefinition>;
    parseNode?: NodeParser;
    postProcessNode?: NodePostProcessor;
    preProcessNode?: NodePreProcessor;
}

// @public
type HierarchyDefinitionParentNode = Omit<NonGroupingHierarchyNode, "children">;

// @public
export type HierarchyFilteringPath = HierarchyNodeIdentifiersPath | {
    path: HierarchyNodeIdentifiersPath;
    options?: HierarchyFilteringPathOptions;
};

// @public (undocumented)
export namespace HierarchyFilteringPath {
    export function mergeOptions(lhs: HierarchyFilteringPathOptions | undefined, rhs: HierarchyFilteringPathOptions | undefined): HierarchyFilteringPathOptions | undefined;
    export function normalize(source: HierarchyFilteringPath): Exclude<HierarchyFilteringPath, HierarchyNodeIdentifiersPath>;
}

// @public (undocumented)
export interface HierarchyFilteringPathOptions {
    autoExpand?: boolean | FilterTargetGroupingNodeInfo | FilteringPathAutoExpandOption | FilteringPathAutoExpandDepthInHierarchy | FilteringPathAutoExpandDepthInPath;
}

// @public
export type HierarchyLevelDefinition = HierarchyNodesDefinition[];

// @public
export type HierarchyNode = NonGroupingHierarchyNode | GroupingHierarchyNode;

// @public (undocumented)
export namespace HierarchyNode {
    export function isClassGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: ClassGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isGeneric<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & NonGroupingHierarchyNode & {
        key: GenericNodeKey;
    };
    export function isGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & GroupingHierarchyNode;
    export function isIModelNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: IModelHierarchyNodeKey;
    };
    export function isInstancesNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    export function isLabelGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: LabelGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyOtherValuesGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyOtherValuesGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyValueGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
    export function isPropertyValueRangeGroupingNode<TNode extends {
        key: HierarchyNodeKey;
    }>(node: TNode): node is TNode & {
        key: PropertyValueRangeGroupingNodeKey;
        supportsFiltering?: undefined;
    } & GroupingHierarchyNode;
}

// @public
type HierarchyNodeAutoExpandProp = "single-child" | "always";

// @public
interface HierarchyNodeBaseClassGroupingParams extends HierarchyNodeGroupingParamsBase {
    fullClassNames: string[];
}

// @public (undocumented)
type HierarchyNodeFilteringProps = {
    hasFilterTargetAncestor?: boolean;
    filteredChildrenIdentifierPaths?: HierarchyFilteringPath[];
} & ({
    isFilterTarget?: false;
} | {
    isFilterTarget: true;
    filterTargetOptions?: HierarchyFilteringPathOptions;
});

// @public (undocumented)
namespace HierarchyNodeFilteringProps {
    // @deprecated (undocumented)
    function create(props: {
        hasFilterTargetAncestor?: boolean;
        filteredChildrenIdentifierPaths?: HierarchyFilteringPath[];
        isFilterTarget?: boolean;
        filterTargetOptions?: HierarchyFilteringPathOptions;
    }): HierarchyNodeFilteringProps | undefined;
}

// @public
interface HierarchyNodeGroupingParams {
    // (undocumented)
    byBaseClasses?: HierarchyNodeBaseClassGroupingParams;
    // (undocumented)
    byClass?: boolean | HierarchyNodeGroupingParamsBase;
    // (undocumented)
    byLabel?: HierarchyNodeLabelGroupingParams;
    // (undocumented)
    byProperties?: HierarchyNodePropertiesGroupingParams;
}

// @public
interface HierarchyNodeGroupingParamsBase {
    autoExpand?: HierarchyNodeAutoExpandProp;
    hideIfNoSiblings?: boolean;
    hideIfOneGroupedNode?: boolean;
}

// @public
export type HierarchyNodeIdentifier = IModelInstanceKey | GenericNodeKey;

// @public (undocumented)
export namespace HierarchyNodeIdentifier {
    export function equal(lhs: HierarchyNodeIdentifier, rhs: HierarchyNodeIdentifier): boolean;
    export function isGenericNodeIdentifier(id: HierarchyNodeIdentifier): id is GenericNodeKey;
    export function isInstanceNodeIdentifier(id: HierarchyNodeIdentifier): id is IModelInstanceKey;
}

// @public
export type HierarchyNodeIdentifiersPath = HierarchyNodeIdentifier[];

// @public
export type HierarchyNodeKey = IModelHierarchyNodeKey | GenericNodeKey;

// @public (undocumented)
export namespace HierarchyNodeKey {
    export function compare(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): number;
    export function equals(lhs: HierarchyNodeKey, rhs: HierarchyNodeKey): boolean;
    export function isClassGrouping(key: HierarchyNodeKey): key is ClassGroupingNodeKey;
    export function isGeneric(key: HierarchyNodeKey): key is GenericNodeKey;
    export function isGrouping(key: HierarchyNodeKey): key is GroupingNodeKey;
    export function isIModelNodeKey(key: HierarchyNodeKey): key is IModelHierarchyNodeKey;
    export function isInstances(key: HierarchyNodeKey): key is InstancesNodeKey;
    export function isLabelGrouping(key: HierarchyNodeKey): key is LabelGroupingNodeKey;
    export function isPropertyGrouping(key: HierarchyNodeKey): key is PropertyGroupingNodeKey;
    export function isPropertyOtherValuesGrouping(key: HierarchyNodeKey): key is PropertyOtherValuesGroupingNodeKey;
    export function isPropertyValueGrouping(key: HierarchyNodeKey): key is PropertyValueGroupingNodeKey;
    export function isPropertyValueRangeGrouping(key: HierarchyNodeKey): key is PropertyValueRangeGroupingNodeKey;
}

// @public
interface HierarchyNodeLabelGroupingBaseParams {
    action?: "group" | "merge";
    groupId?: string;
}

// @public
interface HierarchyNodeLabelGroupingGroupParams extends HierarchyNodeLabelGroupingBaseParams, HierarchyNodeGroupingParamsBase {
    // (undocumented)
    action?: "group";
}

// @public
interface HierarchyNodeLabelGroupingMergeParams extends HierarchyNodeLabelGroupingBaseParams {
    // (undocumented)
    action: "merge";
}

// @public
type HierarchyNodeLabelGroupingParams = boolean | HierarchyNodeLabelGroupingMergeParams | HierarchyNodeLabelGroupingGroupParams;

// @public
interface HierarchyNodeProcessingParamsBase {
    hideIfNoChildren?: boolean;
    hideInHierarchy?: boolean;
}

// @public
interface HierarchyNodePropertiesGroupingParams extends HierarchyNodeGroupingParamsBase {
    createGroupForOutOfRangeValues?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    propertiesClassName: string;
    propertyGroups: HierarchyNodePropertyGroup[];
}

// @public
interface HierarchyNodePropertyGroup {
    propertyName: string;
    propertyValue?: PrimitiveValue | ConcatenatedValue;
    ranges?: HierarchyNodePropertyValueRange[];
}

// @public
interface HierarchyNodePropertyValueRange {
    fromValue: number;
    rangeLabel?: string;
    toValue: number;
}

// @public
export type HierarchyNodesDefinition = GenericHierarchyNodeDefinition | InstanceNodesQueryDefinition;

// @public (undocumented)
export namespace HierarchyNodesDefinition {
    // (undocumented)
    export function isGenericNode(def: HierarchyNodesDefinition): def is GenericHierarchyNodeDefinition;
    // (undocumented)
    export function isInstanceNodesQuery(def: HierarchyNodesDefinition): def is InstanceNodesQueryDefinition;
}

// @public
export interface HierarchyProvider {
    getNodeInstanceKeys(props: Omit<GetHierarchyNodesProps, "ignoreCache">): AsyncIterableIterator<InstanceKey>;
    getNodes(props: GetHierarchyNodesProps): AsyncIterableIterator<HierarchyNode>;
    readonly hierarchyChanged: Event_2<(args?: HierarchyChangedEventArgs) => void>;
    setFormatter(formatter: IPrimitiveValueFormatter | undefined): void;
    setHierarchyFilter(props: {
        paths: HierarchyFilteringPath[];
    } | undefined): void;
}

// @public (undocumented)
type IModelAccess = ECSchemaProvider & LimitingECSqlQueryExecutor & ECClassHierarchyInspector & {
    imodelKey: string;
};

// @public
export type IModelHierarchyNodeKey = InstancesNodeKey | GroupingNodeKey;

// @public
interface IModelHierarchyProviderLocalizedStrings {
    other: string;
    unspecified: string;
}

// @public
interface IModelHierarchyProviderProps {
    filtering?: {
        paths: HierarchyFilteringPath[];
    };
    formatter?: IPrimitiveValueFormatter;
    hierarchyDefinition: HierarchyDefinition;
    imodelAccess: IModelAccess;
    imodelChanged?: Event_2<() => void>;
    localizedStrings?: Partial<IModelHierarchyProviderLocalizedStrings>;
    queryCacheSize?: number;
    queryConcurrency?: number;
}

// @public
interface IModelInstanceKey extends InstanceKey {
    // (undocumented)
    imodelKey?: string;
}

// @public
interface InstanceHierarchyNodeProcessingParams extends HierarchyNodeProcessingParamsBase {
    // (undocumented)
    grouping?: HierarchyNodeGroupingParams;
}

// @public
interface InstanceNodesQueryDefinition {
    fullClassName: string;
    query: ECSqlQueryDef;
}

// @public
interface InstancesNodeChildHierarchyLevelDefinition {
    definitions: (requestProps: DefineInstanceNodeChildHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
    onlyIfNotHandled?: boolean;
    parentInstancesNodePredicate: string | ((parentNodeKey: InstancesNodeKey) => Promise<boolean>);
}

// @public
export interface InstancesNodeKey {
    instanceKeys: IModelInstanceKey[];
    type: "instances";
}

// @public
export interface LabelGroupingNodeKey {
    groupId?: string;
    label: string;
    type: "label-grouping";
}

// @public
export interface LimitingECSqlQueryExecutor {
    createQueryReader(query: ECSqlQueryDef, config?: ECSqlQueryReaderOptions & {
        limit?: number | "unbounded";
    }): ReturnType<ECSqlQueryExecutor["createQueryReader"]>;
}

// @public
interface MergeHierarchyProvidersProps {
    providers: HierarchyProvider[];
}

// @public
export function mergeProviders({ providers }: MergeHierarchyProvidersProps): HierarchyProvider & {
    dispose: () => void;
    [Symbol.dispose]: () => void;
};

// @public
export type NodeParser = (row: {
    [columnName: string]: any;
}, parentNode?: HierarchyDefinitionParentNode) => SourceInstanceHierarchyNode | Promise<SourceInstanceHierarchyNode>;

// @public
export type NodePostProcessor = (node: ProcessedHierarchyNode) => Promise<ProcessedHierarchyNode>;

// @public
export type NodePreProcessor = <TNode extends ProcessedGenericHierarchyNode | ProcessedInstanceHierarchyNode>(node: TNode) => Promise<TNode | undefined>;

// @public (undocumented)
type NodeProps = Pick<HierarchyNode, "autoExpand" | "filtering">;

// @public
export enum NodeSelectClauseColumnNames {
    AutoExpand = "AutoExpand",
    DisplayLabel = "DisplayLabel",
    ECInstanceId = "ECInstanceId",
    ExtendedData = "ExtendedData",
    FullClassName = "FullClassName",
    Grouping = "Grouping",
    HasChildren = "HasChildren",
    HideIfNoChildren = "HideIfNoChildren",
    HideNodeInHierarchy = "HideNodeInHierarchy",
    SupportsFiltering = "SupportsFiltering"
}

// @public
interface NodeSelectClauseProps {
    // (undocumented)
    autoExpand?: boolean | ECSqlValueSelector;
    // (undocumented)
    ecClassId: ECSqlValueSelector;
    // (undocumented)
    ecInstanceId: ECSqlValueSelector;
    // (undocumented)
    extendedData?: {
        [key: string]: Id64String | string | number | boolean | ECSqlValueSelector;
    };
    // (undocumented)
    grouping?: ECSqlSelectClauseGroupingParams;
    // (undocumented)
    hasChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideIfNoChildren?: boolean | ECSqlValueSelector;
    // (undocumented)
    hideNodeInHierarchy?: boolean | ECSqlValueSelector;
    // (undocumented)
    nodeLabel: string | ECSqlValueSelector;
    // (undocumented)
    supportsFiltering?: boolean | ECSqlValueSelector;
}

// @public
export interface NodesQueryClauseFactory {
    createFilterClauses(props: {
        contentClass: {
            fullName: string;
            alias: string;
        };
        filter: GenericInstanceFilter | undefined;
    }): Promise<{
        from: string;
        where: string;
        joins: string;
    }>;
    createSelectClause(props: NodeSelectClauseProps): Promise<string>;
}

// @public
export interface NonGroupingHierarchyNode extends BaseHierarchyNode {
    key: GenericNodeKey | InstancesNodeKey;
    supportsFiltering?: boolean;
}

// @public
type ParentHierarchyNode<TBase = HierarchyNode> = OmitOverUnion<TBase, "children">;

// @public
interface PredicateBasedHierarchyDefinitionProps extends Pick<HierarchyDefinition, "parseNode" | "preProcessNode" | "postProcessNode"> {
    classHierarchyInspector: ECClassHierarchyInspector;
    hierarchy: {
        rootNodes: (props: DefineRootHierarchyLevelProps) => Promise<HierarchyLevelDefinition>;
        childNodes: PredicateBasedHierarchyLevelDefinition[];
    };
}

// @public
type PredicateBasedHierarchyLevelDefinition = InstancesNodeChildHierarchyLevelDefinition | GenericNodeChildHierarchyLevelDefinition;

// @public
type ProcessedGenericHierarchyNode = Omit<NonGroupingHierarchyNode, "key" | "children"> & {
    key: GenericNodeKey;
    children?: boolean;
    processingParams?: HierarchyNodeProcessingParamsBase;
};

// @public
type ProcessedGroupingHierarchyNode = Omit<GroupingHierarchyNode, "children"> & {
    children: Array<ProcessedGroupingHierarchyNode | ProcessedInstanceHierarchyNode>;
};

// @public
export type ProcessedHierarchyNode = ProcessedGenericHierarchyNode | ProcessedInstanceHierarchyNode | ProcessedGroupingHierarchyNode;

// @public (undocumented)
export namespace ProcessedHierarchyNode {
    export function isGeneric(node: ProcessedHierarchyNode): node is ProcessedGenericHierarchyNode;
    export function isGroupingNode(node: ProcessedHierarchyNode): node is ProcessedGroupingHierarchyNode;
    export function isInstancesNode(node: ProcessedHierarchyNode): node is ProcessedInstanceHierarchyNode;
}

// @public
type ProcessedInstanceHierarchyNode = Omit<NonGroupingHierarchyNode, "key" | "children"> & {
    key: InstancesNodeKey;
    children?: boolean;
    processingParams?: InstanceHierarchyNodeProcessingParams;
};

// @public
export type PropertyGroupingNodeKey = PropertyValueRangeGroupingNodeKey | PropertyValueGroupingNodeKey | PropertyOtherValuesGroupingNodeKey;

// @public
export interface PropertyOtherValuesGroupingNodeKey {
    properties: Array<{
        className: string;
        propertyName: string;
    }>;
    type: "property-grouping:other";
}

// @public
export interface PropertyValueGroupingNodeKey {
    formattedPropertyValue: string;
    propertyClassName: string;
    propertyName: string;
    type: "property-grouping:value";
}

// @public
export interface PropertyValueRangeGroupingNodeKey {
    fromValue: number;
    propertyClassName: string;
    propertyName: string;
    toValue: number;
    type: "property-grouping:range";
}

// @public
export class RowsLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @public
export function setLogger(logger: ILogger | undefined): void;

// @public
type SourceGenericHierarchyNode = SourceHierarchyNode<Omit<ProcessedGenericHierarchyNode, "key"> & {
    key: string;
}>;

// @public
export type SourceHierarchyNode<TBase = SourceGenericHierarchyNode | SourceInstanceHierarchyNode> = OmitOverUnion<TBase, "label" | "parentKeys"> & {
    label: string | ConcatenatedValue;
};

// @public
type SourceInstanceHierarchyNode = SourceHierarchyNode<Omit<ProcessedInstanceHierarchyNode, "key"> & {
    key: Omit<InstancesNodeKey, "instanceKeys"> & {
        instanceKeys: InstanceKey[];
    };
}>;

// (No @packageDocumentation comment for this package)

```
